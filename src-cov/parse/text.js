/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['parse/text.js']) {
  _$jscoverage['parse/text.js'] = [];
  _$jscoverage['parse/text.js'][12] = 0;
  _$jscoverage['parse/text.js'][14] = 0;
  _$jscoverage['parse/text.js'][20] = 0;
  _$jscoverage['parse/text.js'][59] = 0;
  _$jscoverage['parse/text.js'][73] = 0;
  _$jscoverage['parse/text.js'][74] = 0;
  _$jscoverage['parse/text.js'][83] = 0;
  _$jscoverage['parse/text.js'][84] = 0;
  _$jscoverage['parse/text.js'][88] = 0;
  _$jscoverage['parse/text.js'][91] = 0;
  _$jscoverage['parse/text.js'][92] = 0;
  _$jscoverage['parse/text.js'][93] = 0;
  _$jscoverage['parse/text.js'][94] = 0;
  _$jscoverage['parse/text.js'][95] = 0;
  _$jscoverage['parse/text.js'][97] = 0;
  _$jscoverage['parse/text.js'][98] = 0;
  _$jscoverage['parse/text.js'][99] = 0;
  _$jscoverage['parse/text.js'][100] = 0;
  _$jscoverage['parse/text.js'][101] = 0;
  _$jscoverage['parse/text.js'][102] = 0;
  _$jscoverage['parse/text.js'][103] = 0;
  _$jscoverage['parse/text.js'][108] = 0;
  _$jscoverage['parse/text.js'][109] = 0;
  _$jscoverage['parse/text.js'][113] = 0;
  _$jscoverage['parse/text.js'][121] = 0;
  _$jscoverage['parse/text.js'][122] = 0;
  _$jscoverage['parse/text.js'][123] = 0;
  _$jscoverage['parse/text.js'][124] = 0;
  _$jscoverage['parse/text.js'][133] = 0;
  _$jscoverage['parse/text.js'][134] = 0;
  _$jscoverage['parse/text.js'][138] = 0;
  _$jscoverage['parse/text.js'][139] = 0;
  _$jscoverage['parse/text.js'][142] = 0;
  _$jscoverage['parse/text.js'][151] = 0;
  _$jscoverage['parse/text.js'][152] = 0;
  _$jscoverage['parse/text.js'][153] = 0;
  _$jscoverage['parse/text.js'][154] = 0;
  _$jscoverage['parse/text.js'][156] = 0;
  _$jscoverage['parse/text.js'][164] = 0;
  _$jscoverage['parse/text.js'][165] = 0;
  _$jscoverage['parse/text.js'][167] = 0;
  _$jscoverage['parse/text.js'][168] = 0;
  _$jscoverage['parse/text.js'][170] = 0;
  _$jscoverage['parse/text.js'][171] = 0;
  _$jscoverage['parse/text.js'][174] = 0;
  _$jscoverage['parse/text.js'][175] = 0;
  _$jscoverage['parse/text.js'][176] = 0;
  _$jscoverage['parse/text.js'][178] = 0;
  _$jscoverage['parse/text.js'][179] = 0;
  _$jscoverage['parse/text.js'][180] = 0;
  _$jscoverage['parse/text.js'][181] = 0;
  _$jscoverage['parse/text.js'][183] = 0;
  _$jscoverage['parse/text.js'][184] = 0;
  _$jscoverage['parse/text.js'][185] = 0;
  _$jscoverage['parse/text.js'][186] = 0;
  _$jscoverage['parse/text.js'][187] = 0;
  _$jscoverage['parse/text.js'][198] = 0;
  _$jscoverage['parse/text.js'][199] = 0;
  _$jscoverage['parse/text.js'][200] = 0;
  _$jscoverage['parse/text.js'][202] = 0;
  _$jscoverage['parse/text.js'][203] = 0;
  _$jscoverage['parse/text.js'][206] = 0;
  _$jscoverage['parse/text.js'][209] = 0;
  _$jscoverage['parse/text.js'][220] = 0;
  _$jscoverage['parse/text.js'][221] = 0;
  _$jscoverage['parse/text.js'][222] = 0;
  _$jscoverage['parse/text.js'][223] = 0;
  _$jscoverage['parse/text.js'][225] = 0;
  _$jscoverage['parse/text.js'][226] = 0;
  _$jscoverage['parse/text.js'][228] = 0;
  _$jscoverage['parse/text.js'][233] = 0;
  _$jscoverage['parse/text.js'][235] = 0;
  _$jscoverage['parse/text.js'][236] = 0;
  _$jscoverage['parse/text.js'][238] = 0;
  _$jscoverage['parse/text.js'][239] = 0;
  _$jscoverage['parse/text.js'][240] = 0;
  _$jscoverage['parse/text.js'][243] = 0;
  _$jscoverage['parse/text.js'][244] = 0;
  _$jscoverage['parse/text.js'][246] = 0;
  _$jscoverage['parse/text.js'][248] = 0;
  _$jscoverage['parse/text.js'][249] = 0;
  _$jscoverage['parse/text.js'][250] = 0;
  _$jscoverage['parse/text.js'][253] = 0;
  _$jscoverage['parse/text.js'][254] = 0;
  _$jscoverage['parse/text.js'][256] = 0;
  _$jscoverage['parse/text.js'][258] = 0;
  _$jscoverage['parse/text.js'][259] = 0;
  _$jscoverage['parse/text.js'][261] = 0;
  _$jscoverage['parse/text.js'][262] = 0;
  _$jscoverage['parse/text.js'][264] = 0;
  _$jscoverage['parse/text.js'][265] = 0;
  _$jscoverage['parse/text.js'][267] = 0;
  _$jscoverage['parse/text.js'][268] = 0;
  _$jscoverage['parse/text.js'][270] = 0;
  _$jscoverage['parse/text.js'][271] = 0;
  _$jscoverage['parse/text.js'][272] = 0;
  _$jscoverage['parse/text.js'][274] = 0;
  _$jscoverage['parse/text.js'][276] = 0;
  _$jscoverage['parse/text.js'][278] = 0;
  _$jscoverage['parse/text.js'][279] = 0;
  _$jscoverage['parse/text.js'][281] = 0;
  _$jscoverage['parse/text.js'][282] = 0;
  _$jscoverage['parse/text.js'][284] = 0;
  _$jscoverage['parse/text.js'][288] = 0;
  _$jscoverage['parse/text.js'][297] = 0;
  _$jscoverage['parse/text.js'][298] = 0;
  _$jscoverage['parse/text.js'][303] = 0;
  _$jscoverage['parse/text.js'][305] = 0;
  _$jscoverage['parse/text.js'][306] = 0;
  _$jscoverage['parse/text.js'][308] = 0;
  _$jscoverage['parse/text.js'][309] = 0;
  _$jscoverage['parse/text.js'][311] = 0;
  _$jscoverage['parse/text.js'][312] = 0;
  _$jscoverage['parse/text.js'][314] = 0;
  _$jscoverage['parse/text.js'][315] = 0;
  _$jscoverage['parse/text.js'][317] = 0;
  _$jscoverage['parse/text.js'][318] = 0;
  _$jscoverage['parse/text.js'][320] = 0;
  _$jscoverage['parse/text.js'][321] = 0;
  _$jscoverage['parse/text.js'][323] = 0;
  _$jscoverage['parse/text.js'][324] = 0;
  _$jscoverage['parse/text.js'][326] = 0;
  _$jscoverage['parse/text.js'][327] = 0;
  _$jscoverage['parse/text.js'][329] = 0;
  _$jscoverage['parse/text.js'][330] = 0;
  _$jscoverage['parse/text.js'][332] = 0;
  _$jscoverage['parse/text.js'][333] = 0;
  _$jscoverage['parse/text.js'][335] = 0;
  _$jscoverage['parse/text.js'][336] = 0;
  _$jscoverage['parse/text.js'][338] = 0;
  _$jscoverage['parse/text.js'][341] = 0;
  _$jscoverage['parse/text.js'][350] = 0;
  _$jscoverage['parse/text.js'][351] = 0;
  _$jscoverage['parse/text.js'][352] = 0;
  _$jscoverage['parse/text.js'][353] = 0;
  _$jscoverage['parse/text.js'][355] = 0;
  _$jscoverage['parse/text.js'][363] = 0;
  _$jscoverage['parse/text.js'][364] = 0;
  _$jscoverage['parse/text.js'][365] = 0;
  _$jscoverage['parse/text.js'][366] = 0;
  _$jscoverage['parse/text.js'][369] = 0;
  _$jscoverage['parse/text.js'][371] = 0;
  _$jscoverage['parse/text.js'][379] = 0;
  _$jscoverage['parse/text.js'][380] = 0;
  _$jscoverage['parse/text.js'][390] = 0;
  _$jscoverage['parse/text.js'][391] = 0;
  _$jscoverage['parse/text.js'][393] = 0;
  _$jscoverage['parse/text.js'][395] = 0;
  _$jscoverage['parse/text.js'][399] = 0;
  _$jscoverage['parse/text.js'][400] = 0;
  _$jscoverage['parse/text.js'][403] = 0;
  _$jscoverage['parse/text.js'][404] = 0;
  _$jscoverage['parse/text.js'][408] = 0;
  _$jscoverage['parse/text.js'][409] = 0;
  _$jscoverage['parse/text.js'][412] = 0;
  _$jscoverage['parse/text.js'][415] = 0;
}
_$jscoverage['parse/text.js'].source = ["/**","* Parses an English string expression and produces a schedule that is","* compatible with Later.js.","*","* Examples:","*","* every 5 minutes between the 1st and 30th minute","* at 10:00 am on tues of may in 2012","* on the 15-20th day of march-dec","* every 20 seconds every 5 minutes every 4 hours between the 10th and 20th hour","*/","later.parse.text = function(str) {","","  var recur = later.parse.recur,","      pos = 0,","      input = '',","      error;","","  // Regex expressions for all of the valid tokens","  var TOKENTYPES = {","        eof: /^$/,","        rank: /^((\\d\\d\\d\\d)|([2-5]?1(st)?|[2-5]?2(nd)?|[2-5]?3(rd)?|(0|[1-5]?[4-9]|[1-5]0|1[1-3])(th)?))\\b/,","        time: /^((([0]?[1-9]|1[0-2]):[0-5]\\d(\\s)?(am|pm))|(([0]?\\d|1\\d|2[0-3]):[0-5]\\d))\\b/,","        dayName: /^((sun|mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?)(day)?)\\b/,","        monthName: /^(jan(uary)?|feb(ruary)?|ma((r(ch)?)?|y)|apr(il)?|ju(ly|ne)|aug(ust)?|oct(ober)?|(sept|nov|dec)(ember)?)\\b/,","        yearIndex: /^(\\d\\d\\d\\d)\\b/,","        every: /^every\\b/,","        after: /^after\\b/,","        before: /^before\\b/,","        second: /^(s|sec(ond)?(s)?)\\b/,","        minute: /^(m|min(ute)?(s)?)\\b/,","        hour: /^(h|hour(s)?)\\b/,","        day: /^(day(s)?( of the month)?)\\b/,","        dayInstance: /^day instance\\b/,","        dayOfWeek: /^day(s)? of the week\\b/,","        dayOfYear: /^day(s)? of the year\\b/,","        weekOfYear: /^week(s)?( of the year)?\\b/,","        weekOfMonth: /^week(s)? of the month\\b/,","        weekday: /^weekday\\b/,","        weekend: /^weekend\\b/,","        month: /^month(s)?\\b/,","        year: /^year(s)?\\b/,","        between: /^between (the)?\\b/,","        start: /^(start(ing)? (at|on( the)?)?)\\b/,","        at: /^(at|@)\\b/,","        and: /^(,|and\\b)/,","        except: /^(except\\b)/,","        also: /(also)\\b/,","        first: /^(first)\\b/,","        last: /^last\\b/,","        \"in\": /^in\\b/,","        of: /^of\\b/,","        onthe: /^on the\\b/,","        on: /^on\\b/,","        through: /(-|^(to|through)\\b)/","      };","","  // Array to convert string names to valid numerical values","  var NAMES = { jan: 1, feb: 2, mar: 3, apr: 4, may: 5, jun: 6, jul: 7,","        aug: 8, sep: 9, oct: 10, nov: 11, dec: 12, sun: 1, mon: 2, tue: 3,","        wed: 4, thu: 5, fri: 6, sat: 7, '1st': 1, fir: 1, '2nd': 2, sec: 2,","        '3rd': 3, thi: 3, '4th': 4, 'for': 4","      };","","  /**","  * Bundles up the results of the peek operation into a token.","  *","  * @param {Int} start: The start position of the token","  * @param {Int} end: The end position of the token","  * @param {String} text: The actual text that was parsed","  * @param {TokenType} type: The TokenType of the token","  */","  function t(start, end, text, type) {","    return {startPos: start, endPos: end, text: text, type: type};","  }","","  /**","  * Peeks forward to see if the next token is the expected token and","  * returns the token if found.  Pos is not moved during a Peek operation.","  *","  * @param {TokenType} exepected: The types of token to scan for","  */","  function peek(expected) {","    var scanTokens = expected instanceof Array ? expected : [expected],","        whiteSpace = /\\s+/,","        token, curInput, m, scanToken, start, len;","","    scanTokens.push(whiteSpace);","","    // loop past any skipped tokens and only look for expected tokens","    start = pos;","    while (!token || token.type === whiteSpace) {","      len = -1;","      curInput = input.substring(start);","      token = t(start, start, input.split(whiteSpace)[0]);","","      var i, length = scanTokens.length;","      for(i = 0; i &lt; length; i++) {","        scanToken = scanTokens[i];","        m = scanToken.exec(curInput);","        if (m &amp;&amp; m.index === 0 &amp;&amp; m[0].length &gt; len) {","          len = m[0].length;","          token = t(start, start + len, curInput.substring(0, len), scanToken);","        }","      }","","      // update the start position if this token should be skipped","      if (token.type === whiteSpace) {","        start = token.endPos;","      }","    }","","    return token;","  }","","  /**","  * Moves pos to the end of the expectedToken if it is found.","  *","  * @param {TokenType} exepectedToken: The types of token to scan for","  */","  function scan(expectedToken) {","    var token = peek(expectedToken);","    pos = token.endPos;","    return token;","  }","","  /**","  * Parses the next 'y-z' expression and returns the resulting valid","  * value array.","  *","  * @param {TokenType} tokenType: The type of range values allowed","  */","  function parseThroughExpr(tokenType) {","    var start = +parseTokenValue(tokenType),","        end = checkAndParse(TOKENTYPES.through) ? +parseTokenValue(tokenType) : start,","        nums = [];","","    for (var i = start; i &lt;= end; i++) {","      nums.push(i);","    }","","    return nums;","  }","","  /**","  * Parses the next 'x,y-z' expression and returns the resulting valid","  * value array.","  *","  * @param {TokenType} tokenType: The type of range values allowed","  */","  function parseRanges(tokenType) {","    var nums = parseThroughExpr(tokenType);","    while (checkAndParse(TOKENTYPES.and)) {","      nums = nums.concat(parseThroughExpr(tokenType));","    }","    return nums;","  }","","  /**","  * Parses the next 'every (weekend|weekday|x) (starting on|between)' expression.","  *","  * @param {Recur} r: The recurrence to add the expression to","  */","  function parseEvery(r) {","    var num, period, start, end;","","    if (checkAndParse(TOKENTYPES.weekend)) {","      r.on(NAMES.sun,NAMES.sat).dayOfWeek();","    }","    else if (checkAndParse(TOKENTYPES.weekday)) {","      r.on(NAMES.mon,NAMES.tue,NAMES.wed,NAMES.thu,NAMES.fri).dayOfWeek();","    }","    else {","      num = parseTokenValue(TOKENTYPES.rank);","      r.every(num);","      period = parseTimePeriod(r);","","      if (checkAndParse(TOKENTYPES.start)) {","        num = parseTokenValue(TOKENTYPES.rank);","        r.startingOn(num);","        parseToken(period.type);","      }","      else if (checkAndParse(TOKENTYPES.between)) {","        start = parseTokenValue(TOKENTYPES.rank);","        if (checkAndParse(TOKENTYPES.and)) {","          end = parseTokenValue(TOKENTYPES.rank);","          r.between(start,end);","        }","      }","    }","  }","","  /**","  * Parses the next 'on the (first|last|x,y-z)' expression.","  *","  * @param {Recur} r: The recurrence to add the expression to","  */","  function parseOnThe(r) {","    if (checkAndParse(TOKENTYPES.first)) {","      r.first();","    }","    else if (checkAndParse(TOKENTYPES.last)) {","      r.last();","    }","    else {","      r.on(parseRanges(TOKENTYPES.rank));","    }","","    parseTimePeriod(r);","  }","","  /**","  * Parses the schedule expression and returns the resulting schedules,","  * and exceptions.  Error will return the position in the string where","  * an error occurred, will be null if no errors were found in the","  * expression.","  *","  * @param {String} str: The schedule expression to parse","  */","  function parseScheduleExpr(str) {","    pos = 0;","    input = str;","    error = -1;","","    var r = recur();","    while (pos &lt; input.length &amp;&amp; error &lt; 0) {","","      var token = parseToken([TOKENTYPES.every, TOKENTYPES.after, TOKENTYPES.before,","            TOKENTYPES.onthe, TOKENTYPES.on, TOKENTYPES.of, TOKENTYPES[\"in\"],","            TOKENTYPES.at, TOKENTYPES.and, TOKENTYPES.except,","            TOKENTYPES.also]);","","      switch (token.type) {","        case TOKENTYPES.every:","          parseEvery(r);","          break;","        case TOKENTYPES.after:","          if(peek(TOKENTYPES.time).type !== undefined) {","            r.after(parseTokenValue(TOKENTYPES.time));","            r.time();","          }","          else {","            r.after(parseTokenValue(TOKENTYPES.rank));","            parseTimePeriod(r);","          }","          break;","        case TOKENTYPES.before:","          if(peek(TOKENTYPES.time).type !== undefined) {","            r.before(parseTokenValue(TOKENTYPES.time));","            r.time();","          }","          else {","            r.before(parseTokenValue(TOKENTYPES.rank));","            parseTimePeriod(r);","          }","          break;","        case TOKENTYPES.onthe:","          parseOnThe(r);","          break;","        case TOKENTYPES.on:","          r.on(parseRanges(TOKENTYPES.dayName)).dayOfWeek();","          break;","        case TOKENTYPES.of:","          r.on(parseRanges(TOKENTYPES.monthName)).month();","          break;","        case TOKENTYPES[\"in\"]:","          r.on(parseRanges(TOKENTYPES.yearIndex)).year();","          break;","        case TOKENTYPES.at:","          r.on(parseTokenValue(TOKENTYPES.time)).time();","          while (checkAndParse(TOKENTYPES.and)) {","            r.on(parseTokenValue(TOKENTYPES.time)).time();","          }","          break;","        case TOKENTYPES.and:","          break;","        case TOKENTYPES.also:","          r.and();","          break;","        case TOKENTYPES.except:","          r.except();","          break;","        default:","          error = pos;","      }","    }","","    return {schedules: r.schedules, exceptions: r.exceptions, error: error};","  }","","  /**","  * Parses the next token representing a time period and adds it to","  * the provided recur object.","  *","  * @param {Recur} r: The recurrence to add the time period to","  */","  function parseTimePeriod(r) {","    var timePeriod = parseToken([TOKENTYPES.second, TOKENTYPES.minute,","          TOKENTYPES.hour, TOKENTYPES.dayOfYear, TOKENTYPES.dayOfWeek,","          TOKENTYPES.dayInstance, TOKENTYPES.day, TOKENTYPES.month,","          TOKENTYPES.year, TOKENTYPES.weekOfMonth, TOKENTYPES.weekOfYear]);","","    switch (timePeriod.type) {","      case TOKENTYPES.second:","        r.second();","        break;","      case TOKENTYPES.minute:","        r.minute();","        break;","      case TOKENTYPES.hour:","        r.hour();","        break;","      case TOKENTYPES.dayOfYear:","        r.dayOfYear();","        break;","      case TOKENTYPES.dayOfWeek:","        r.dayOfWeek();","        break;","      case TOKENTYPES.dayInstance:","        r.dayOfWeekCount();","        break;","      case TOKENTYPES.day:","        r.dayOfMonth();","        break;","      case TOKENTYPES.weekOfMonth:","        r.weekOfMonth();","        break;","      case TOKENTYPES.weekOfYear:","        r.weekOfYear();","        break;","      case TOKENTYPES.month:","        r.month();","        break;","      case TOKENTYPES.year:","        r.year();","        break;","      default:","        error = pos;","    }","","    return timePeriod;","  }","","  /**","  * Checks the next token to see if it is of tokenType. Returns true if","  * it is and discards the token.  Returns false otherwise.","  *","  * @param {TokenType} tokenType: The type or types of token to parse","  */","  function checkAndParse(tokenType) {","    var found = (peek(tokenType)).type === tokenType;","    if (found) {","      scan(tokenType);","    }","    return found;","  }","","  /**","  * Parses and returns the next token.","  *","  * @param {TokenType} tokenType: The type or types of token to parse","  */","  function parseToken(tokenType) {","    var t = scan(tokenType);","    if (t.type) {","      t.text = convertString(t.text, tokenType);","    }","    else {","      error = pos;","    }","    return t;","  }","","  /**","  * Returns the text value of the token that was parsed.","  *","  * @param {TokenType} tokenType: The type of token to parse","  */","  function parseTokenValue(tokenType) {","    return (parseToken(tokenType)).text;","  }","","  /**","  * Converts a string value to a numerical value based on the type of","  * token that was parsed.","  *","  * @param {String} str: The schedule string to parse","  * @param {TokenType} tokenType: The type of token to convert","  */","  function convertString(str, tokenType) {","    var output = str;","","    switch (tokenType) {","      case TOKENTYPES.time:","        var parts = str.split(/(:|am|pm)/),","            hour = parts[3] === 'pm' &amp;&amp; parts[0] &lt; 12 ? parseInt(parts[0],10) + 12 : parts[0],","            min = parts[2].trim();","","        output = (hour.length === 1 ? '0' : '') + hour + \":\" + min;","        break;","","      case TOKENTYPES.rank:","        output = parseInt((/^\\d+/.exec(str))[0],10);","        break;","","      case TOKENTYPES.monthName:","      case TOKENTYPES.dayName:","        output = NAMES[str.substring(0,3)];","        break;","    }","","    return output;","  }","","  return parseScheduleExpr(str.toLowerCase());","};"];
_$jscoverage['parse/text.js'][12]++;
later.parse.text = (function (str) {
  _$jscoverage['parse/text.js'][14]++;
  var recur = later.parse.recur, pos = 0, input = "", error;
  _$jscoverage['parse/text.js'][20]++;
  var TOKENTYPES = {eof: /^$/, rank: /^((\d\d\d\d)|([2-5]?1(st)?|[2-5]?2(nd)?|[2-5]?3(rd)?|(0|[1-5]?[4-9]|[1-5]0|1[1-3])(th)?))\b/, time: /^((([0]?[1-9]|1[0-2]):[0-5]\d(\s)?(am|pm))|(([0]?\d|1\d|2[0-3]):[0-5]\d))\b/, dayName: /^((sun|mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?)(day)?)\b/, monthName: /^(jan(uary)?|feb(ruary)?|ma((r(ch)?)?|y)|apr(il)?|ju(ly|ne)|aug(ust)?|oct(ober)?|(sept|nov|dec)(ember)?)\b/, yearIndex: /^(\d\d\d\d)\b/, every: /^every\b/, after: /^after\b/, before: /^before\b/, second: /^(s|sec(ond)?(s)?)\b/, minute: /^(m|min(ute)?(s)?)\b/, hour: /^(h|hour(s)?)\b/, day: /^(day(s)?( of the month)?)\b/, dayInstance: /^day instance\b/, dayOfWeek: /^day(s)? of the week\b/, dayOfYear: /^day(s)? of the year\b/, weekOfYear: /^week(s)?( of the year)?\b/, weekOfMonth: /^week(s)? of the month\b/, weekday: /^weekday\b/, weekend: /^weekend\b/, month: /^month(s)?\b/, year: /^year(s)?\b/, between: /^between (the)?\b/, start: /^(start(ing)? (at|on( the)?)?)\b/, at: /^(at|@)\b/, and: /^(,|and\b)/, except: /^(except\b)/, also: /(also)\b/, first: /^(first)\b/, last: /^last\b/, "in": /^in\b/, of: /^of\b/, onthe: /^on the\b/, on: /^on\b/, through: /(-|^(to|through)\b)/};
  _$jscoverage['parse/text.js'][59]++;
  var NAMES = {jan: 1, feb: 2, mar: 3, apr: 4, may: 5, jun: 6, jul: 7, aug: 8, sep: 9, oct: 10, nov: 11, dec: 12, sun: 1, mon: 2, tue: 3, wed: 4, thu: 5, fri: 6, sat: 7, "1st": 1, fir: 1, "2nd": 2, sec: 2, "3rd": 3, thi: 3, "4th": 4, "for": 4};
  _$jscoverage['parse/text.js'][73]++;
  function t(start, end, text, type) {
    _$jscoverage['parse/text.js'][74]++;
    return ({startPos: start, endPos: end, text: text, type: type});
}
  _$jscoverage['parse/text.js'][83]++;
  function peek(expected) {
    _$jscoverage['parse/text.js'][84]++;
    var scanTokens = ((expected instanceof Array)? expected: [expected]), whiteSpace = /\s+/, token, curInput, m, scanToken, start, len;
    _$jscoverage['parse/text.js'][88]++;
    scanTokens.push(whiteSpace);
    _$jscoverage['parse/text.js'][91]++;
    start = pos;
    _$jscoverage['parse/text.js'][92]++;
    while (((! token) || (token.type === whiteSpace))) {
      _$jscoverage['parse/text.js'][93]++;
      len = -1;
      _$jscoverage['parse/text.js'][94]++;
      curInput = input.substring(start);
      _$jscoverage['parse/text.js'][95]++;
      token = t(start, start, input.split(whiteSpace)[0]);
      _$jscoverage['parse/text.js'][97]++;
      var i, length = scanTokens.length;
      _$jscoverage['parse/text.js'][98]++;
      for (i = 0; (i < length); (i++)) {
        _$jscoverage['parse/text.js'][99]++;
        scanToken = scanTokens[i];
        _$jscoverage['parse/text.js'][100]++;
        m = scanToken.exec(curInput);
        _$jscoverage['parse/text.js'][101]++;
        if ((m && (m.index === 0) && (m[0].length > len))) {
          _$jscoverage['parse/text.js'][102]++;
          len = m[0].length;
          _$jscoverage['parse/text.js'][103]++;
          token = t(start, (start + len), curInput.substring(0, len), scanToken);
        }
}
      _$jscoverage['parse/text.js'][108]++;
      if ((token.type === whiteSpace)) {
        _$jscoverage['parse/text.js'][109]++;
        start = token.endPos;
      }
}
    _$jscoverage['parse/text.js'][113]++;
    return token;
}
  _$jscoverage['parse/text.js'][121]++;
  function scan(expectedToken) {
    _$jscoverage['parse/text.js'][122]++;
    var token = peek(expectedToken);
    _$jscoverage['parse/text.js'][123]++;
    pos = token.endPos;
    _$jscoverage['parse/text.js'][124]++;
    return token;
}
  _$jscoverage['parse/text.js'][133]++;
  function parseThroughExpr(tokenType) {
    _$jscoverage['parse/text.js'][134]++;
    var start = (+ parseTokenValue(tokenType)), end = (checkAndParse(TOKENTYPES.through)? (+ parseTokenValue(tokenType)): start), nums = [];
    _$jscoverage['parse/text.js'][138]++;
    for (var i = start; (i <= end); (i++)) {
      _$jscoverage['parse/text.js'][139]++;
      nums.push(i);
}
    _$jscoverage['parse/text.js'][142]++;
    return nums;
}
  _$jscoverage['parse/text.js'][151]++;
  function parseRanges(tokenType) {
    _$jscoverage['parse/text.js'][152]++;
    var nums = parseThroughExpr(tokenType);
    _$jscoverage['parse/text.js'][153]++;
    while (checkAndParse(TOKENTYPES.and)) {
      _$jscoverage['parse/text.js'][154]++;
      nums = nums.concat(parseThroughExpr(tokenType));
}
    _$jscoverage['parse/text.js'][156]++;
    return nums;
}
  _$jscoverage['parse/text.js'][164]++;
  function parseEvery(r) {
    _$jscoverage['parse/text.js'][165]++;
    var num, period, start, end;
    _$jscoverage['parse/text.js'][167]++;
    if (checkAndParse(TOKENTYPES.weekend)) {
      _$jscoverage['parse/text.js'][168]++;
      r.on(NAMES.sun, NAMES.sat).dayOfWeek();
    }
    else {
      _$jscoverage['parse/text.js'][170]++;
      if (checkAndParse(TOKENTYPES.weekday)) {
        _$jscoverage['parse/text.js'][171]++;
        r.on(NAMES.mon, NAMES.tue, NAMES.wed, NAMES.thu, NAMES.fri).dayOfWeek();
      }
      else {
        _$jscoverage['parse/text.js'][174]++;
        num = parseTokenValue(TOKENTYPES.rank);
        _$jscoverage['parse/text.js'][175]++;
        r.every(num);
        _$jscoverage['parse/text.js'][176]++;
        period = parseTimePeriod(r);
        _$jscoverage['parse/text.js'][178]++;
        if (checkAndParse(TOKENTYPES.start)) {
          _$jscoverage['parse/text.js'][179]++;
          num = parseTokenValue(TOKENTYPES.rank);
          _$jscoverage['parse/text.js'][180]++;
          r.startingOn(num);
          _$jscoverage['parse/text.js'][181]++;
          parseToken(period.type);
        }
        else {
          _$jscoverage['parse/text.js'][183]++;
          if (checkAndParse(TOKENTYPES.between)) {
            _$jscoverage['parse/text.js'][184]++;
            start = parseTokenValue(TOKENTYPES.rank);
            _$jscoverage['parse/text.js'][185]++;
            if (checkAndParse(TOKENTYPES.and)) {
              _$jscoverage['parse/text.js'][186]++;
              end = parseTokenValue(TOKENTYPES.rank);
              _$jscoverage['parse/text.js'][187]++;
              r.between(start, end);
            }
          }
        }
      }
    }
}
  _$jscoverage['parse/text.js'][198]++;
  function parseOnThe(r) {
    _$jscoverage['parse/text.js'][199]++;
    if (checkAndParse(TOKENTYPES.first)) {
      _$jscoverage['parse/text.js'][200]++;
      r.first();
    }
    else {
      _$jscoverage['parse/text.js'][202]++;
      if (checkAndParse(TOKENTYPES.last)) {
        _$jscoverage['parse/text.js'][203]++;
        r.last();
      }
      else {
        _$jscoverage['parse/text.js'][206]++;
        r.on(parseRanges(TOKENTYPES.rank));
      }
    }
    _$jscoverage['parse/text.js'][209]++;
    parseTimePeriod(r);
}
  _$jscoverage['parse/text.js'][220]++;
  function parseScheduleExpr(str) {
    _$jscoverage['parse/text.js'][221]++;
    pos = 0;
    _$jscoverage['parse/text.js'][222]++;
    input = str;
    _$jscoverage['parse/text.js'][223]++;
    error = -1;
    _$jscoverage['parse/text.js'][225]++;
    var r = recur();
    _$jscoverage['parse/text.js'][226]++;
    while (((pos < input.length) && (error < 0))) {
      _$jscoverage['parse/text.js'][228]++;
      var token = parseToken([TOKENTYPES.every, TOKENTYPES.after, TOKENTYPES.before, TOKENTYPES.onthe, TOKENTYPES.on, TOKENTYPES.of, TOKENTYPES["in"], TOKENTYPES.at, TOKENTYPES.and, TOKENTYPES.except, TOKENTYPES.also]);
      _$jscoverage['parse/text.js'][233]++;
      switch (token.type) {
      case TOKENTYPES.every:
        _$jscoverage['parse/text.js'][235]++;
        parseEvery(r);
        _$jscoverage['parse/text.js'][236]++;
        break;
      case TOKENTYPES.after:
        _$jscoverage['parse/text.js'][238]++;
        if ((peek(TOKENTYPES.time).type !== undefined)) {
          _$jscoverage['parse/text.js'][239]++;
          r.after(parseTokenValue(TOKENTYPES.time));
          _$jscoverage['parse/text.js'][240]++;
          r.time();
        }
        else {
          _$jscoverage['parse/text.js'][243]++;
          r.after(parseTokenValue(TOKENTYPES.rank));
          _$jscoverage['parse/text.js'][244]++;
          parseTimePeriod(r);
        }
        _$jscoverage['parse/text.js'][246]++;
        break;
      case TOKENTYPES.before:
        _$jscoverage['parse/text.js'][248]++;
        if ((peek(TOKENTYPES.time).type !== undefined)) {
          _$jscoverage['parse/text.js'][249]++;
          r.before(parseTokenValue(TOKENTYPES.time));
          _$jscoverage['parse/text.js'][250]++;
          r.time();
        }
        else {
          _$jscoverage['parse/text.js'][253]++;
          r.before(parseTokenValue(TOKENTYPES.rank));
          _$jscoverage['parse/text.js'][254]++;
          parseTimePeriod(r);
        }
        _$jscoverage['parse/text.js'][256]++;
        break;
      case TOKENTYPES.onthe:
        _$jscoverage['parse/text.js'][258]++;
        parseOnThe(r);
        _$jscoverage['parse/text.js'][259]++;
        break;
      case TOKENTYPES.on:
        _$jscoverage['parse/text.js'][261]++;
        r.on(parseRanges(TOKENTYPES.dayName)).dayOfWeek();
        _$jscoverage['parse/text.js'][262]++;
        break;
      case TOKENTYPES.of:
        _$jscoverage['parse/text.js'][264]++;
        r.on(parseRanges(TOKENTYPES.monthName)).month();
        _$jscoverage['parse/text.js'][265]++;
        break;
      case TOKENTYPES["in"]:
        _$jscoverage['parse/text.js'][267]++;
        r.on(parseRanges(TOKENTYPES.yearIndex)).year();
        _$jscoverage['parse/text.js'][268]++;
        break;
      case TOKENTYPES.at:
        _$jscoverage['parse/text.js'][270]++;
        r.on(parseTokenValue(TOKENTYPES.time)).time();
        _$jscoverage['parse/text.js'][271]++;
        while (checkAndParse(TOKENTYPES.and)) {
          _$jscoverage['parse/text.js'][272]++;
          r.on(parseTokenValue(TOKENTYPES.time)).time();
}
        _$jscoverage['parse/text.js'][274]++;
        break;
      case TOKENTYPES.and:
        _$jscoverage['parse/text.js'][276]++;
        break;
      case TOKENTYPES.also:
        _$jscoverage['parse/text.js'][278]++;
        r.and();
        _$jscoverage['parse/text.js'][279]++;
        break;
      case TOKENTYPES.except:
        _$jscoverage['parse/text.js'][281]++;
        r.except();
        _$jscoverage['parse/text.js'][282]++;
        break;
      default:
        _$jscoverage['parse/text.js'][284]++;
        error = pos;
      }
}
    _$jscoverage['parse/text.js'][288]++;
    return ({schedules: r.schedules, exceptions: r.exceptions, error: error});
}
  _$jscoverage['parse/text.js'][297]++;
  function parseTimePeriod(r) {
    _$jscoverage['parse/text.js'][298]++;
    var timePeriod = parseToken([TOKENTYPES.second, TOKENTYPES.minute, TOKENTYPES.hour, TOKENTYPES.dayOfYear, TOKENTYPES.dayOfWeek, TOKENTYPES.dayInstance, TOKENTYPES.day, TOKENTYPES.month, TOKENTYPES.year, TOKENTYPES.weekOfMonth, TOKENTYPES.weekOfYear]);
    _$jscoverage['parse/text.js'][303]++;
    switch (timePeriod.type) {
    case TOKENTYPES.second:
      _$jscoverage['parse/text.js'][305]++;
      r.second();
      _$jscoverage['parse/text.js'][306]++;
      break;
    case TOKENTYPES.minute:
      _$jscoverage['parse/text.js'][308]++;
      r.minute();
      _$jscoverage['parse/text.js'][309]++;
      break;
    case TOKENTYPES.hour:
      _$jscoverage['parse/text.js'][311]++;
      r.hour();
      _$jscoverage['parse/text.js'][312]++;
      break;
    case TOKENTYPES.dayOfYear:
      _$jscoverage['parse/text.js'][314]++;
      r.dayOfYear();
      _$jscoverage['parse/text.js'][315]++;
      break;
    case TOKENTYPES.dayOfWeek:
      _$jscoverage['parse/text.js'][317]++;
      r.dayOfWeek();
      _$jscoverage['parse/text.js'][318]++;
      break;
    case TOKENTYPES.dayInstance:
      _$jscoverage['parse/text.js'][320]++;
      r.dayOfWeekCount();
      _$jscoverage['parse/text.js'][321]++;
      break;
    case TOKENTYPES.day:
      _$jscoverage['parse/text.js'][323]++;
      r.dayOfMonth();
      _$jscoverage['parse/text.js'][324]++;
      break;
    case TOKENTYPES.weekOfMonth:
      _$jscoverage['parse/text.js'][326]++;
      r.weekOfMonth();
      _$jscoverage['parse/text.js'][327]++;
      break;
    case TOKENTYPES.weekOfYear:
      _$jscoverage['parse/text.js'][329]++;
      r.weekOfYear();
      _$jscoverage['parse/text.js'][330]++;
      break;
    case TOKENTYPES.month:
      _$jscoverage['parse/text.js'][332]++;
      r.month();
      _$jscoverage['parse/text.js'][333]++;
      break;
    case TOKENTYPES.year:
      _$jscoverage['parse/text.js'][335]++;
      r.year();
      _$jscoverage['parse/text.js'][336]++;
      break;
    default:
      _$jscoverage['parse/text.js'][338]++;
      error = pos;
    }
    _$jscoverage['parse/text.js'][341]++;
    return timePeriod;
}
  _$jscoverage['parse/text.js'][350]++;
  function checkAndParse(tokenType) {
    _$jscoverage['parse/text.js'][351]++;
    var found = (peek(tokenType).type === tokenType);
    _$jscoverage['parse/text.js'][352]++;
    if (found) {
      _$jscoverage['parse/text.js'][353]++;
      scan(tokenType);
    }
    _$jscoverage['parse/text.js'][355]++;
    return found;
}
  _$jscoverage['parse/text.js'][363]++;
  function parseToken(tokenType) {
    _$jscoverage['parse/text.js'][364]++;
    var t = scan(tokenType);
    _$jscoverage['parse/text.js'][365]++;
    if (t.type) {
      _$jscoverage['parse/text.js'][366]++;
      t.text = convertString(t.text, tokenType);
    }
    else {
      _$jscoverage['parse/text.js'][369]++;
      error = pos;
    }
    _$jscoverage['parse/text.js'][371]++;
    return t;
}
  _$jscoverage['parse/text.js'][379]++;
  function parseTokenValue(tokenType) {
    _$jscoverage['parse/text.js'][380]++;
    return parseToken(tokenType).text;
}
  _$jscoverage['parse/text.js'][390]++;
  function convertString(str, tokenType) {
    _$jscoverage['parse/text.js'][391]++;
    var output = str;
    _$jscoverage['parse/text.js'][393]++;
    switch (tokenType) {
    case TOKENTYPES.time:
      _$jscoverage['parse/text.js'][395]++;
      var parts = str.split(/(:|am|pm)/), hour = (((parts[3] === "pm") && (parts[0] < 12))? (parseInt(parts[0], 10) + 12): parts[0]), min = parts[2].trim();
      _$jscoverage['parse/text.js'][399]++;
      output = (((hour.length === 1)? "0": "") + hour + ":" + min);
      _$jscoverage['parse/text.js'][400]++;
      break;
    case TOKENTYPES.rank:
      _$jscoverage['parse/text.js'][403]++;
      output = parseInt(/^\d+/.exec(str)[0], 10);
      _$jscoverage['parse/text.js'][404]++;
      break;
    case TOKENTYPES.monthName:
    case TOKENTYPES.dayName:
      _$jscoverage['parse/text.js'][408]++;
      output = NAMES[str.substring(0, 3)];
      _$jscoverage['parse/text.js'][409]++;
      break;
    }
    _$jscoverage['parse/text.js'][412]++;
    return output;
}
  _$jscoverage['parse/text.js'][415]++;
  return parseScheduleExpr(str.toLowerCase());
});
