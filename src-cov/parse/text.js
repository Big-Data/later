/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['parse/text.js']) {
  _$jscoverage['parse/text.js'] = [];
  _$jscoverage['parse/text.js'][12] = 0;
  _$jscoverage['parse/text.js'][14] = 0;
  _$jscoverage['parse/text.js'][20] = 0;
  _$jscoverage['parse/text.js'][58] = 0;
  _$jscoverage['parse/text.js'][72] = 0;
  _$jscoverage['parse/text.js'][73] = 0;
  _$jscoverage['parse/text.js'][82] = 0;
  _$jscoverage['parse/text.js'][83] = 0;
  _$jscoverage['parse/text.js'][87] = 0;
  _$jscoverage['parse/text.js'][90] = 0;
  _$jscoverage['parse/text.js'][91] = 0;
  _$jscoverage['parse/text.js'][92] = 0;
  _$jscoverage['parse/text.js'][93] = 0;
  _$jscoverage['parse/text.js'][94] = 0;
  _$jscoverage['parse/text.js'][96] = 0;
  _$jscoverage['parse/text.js'][97] = 0;
  _$jscoverage['parse/text.js'][98] = 0;
  _$jscoverage['parse/text.js'][99] = 0;
  _$jscoverage['parse/text.js'][100] = 0;
  _$jscoverage['parse/text.js'][101] = 0;
  _$jscoverage['parse/text.js'][102] = 0;
  _$jscoverage['parse/text.js'][107] = 0;
  _$jscoverage['parse/text.js'][108] = 0;
  _$jscoverage['parse/text.js'][112] = 0;
  _$jscoverage['parse/text.js'][120] = 0;
  _$jscoverage['parse/text.js'][121] = 0;
  _$jscoverage['parse/text.js'][122] = 0;
  _$jscoverage['parse/text.js'][123] = 0;
  _$jscoverage['parse/text.js'][132] = 0;
  _$jscoverage['parse/text.js'][133] = 0;
  _$jscoverage['parse/text.js'][137] = 0;
  _$jscoverage['parse/text.js'][138] = 0;
  _$jscoverage['parse/text.js'][141] = 0;
  _$jscoverage['parse/text.js'][150] = 0;
  _$jscoverage['parse/text.js'][151] = 0;
  _$jscoverage['parse/text.js'][152] = 0;
  _$jscoverage['parse/text.js'][153] = 0;
  _$jscoverage['parse/text.js'][155] = 0;
  _$jscoverage['parse/text.js'][163] = 0;
  _$jscoverage['parse/text.js'][164] = 0;
  _$jscoverage['parse/text.js'][166] = 0;
  _$jscoverage['parse/text.js'][167] = 0;
  _$jscoverage['parse/text.js'][169] = 0;
  _$jscoverage['parse/text.js'][170] = 0;
  _$jscoverage['parse/text.js'][173] = 0;
  _$jscoverage['parse/text.js'][174] = 0;
  _$jscoverage['parse/text.js'][175] = 0;
  _$jscoverage['parse/text.js'][177] = 0;
  _$jscoverage['parse/text.js'][178] = 0;
  _$jscoverage['parse/text.js'][179] = 0;
  _$jscoverage['parse/text.js'][180] = 0;
  _$jscoverage['parse/text.js'][182] = 0;
  _$jscoverage['parse/text.js'][183] = 0;
  _$jscoverage['parse/text.js'][184] = 0;
  _$jscoverage['parse/text.js'][185] = 0;
  _$jscoverage['parse/text.js'][186] = 0;
  _$jscoverage['parse/text.js'][197] = 0;
  _$jscoverage['parse/text.js'][198] = 0;
  _$jscoverage['parse/text.js'][199] = 0;
  _$jscoverage['parse/text.js'][201] = 0;
  _$jscoverage['parse/text.js'][202] = 0;
  _$jscoverage['parse/text.js'][205] = 0;
  _$jscoverage['parse/text.js'][208] = 0;
  _$jscoverage['parse/text.js'][219] = 0;
  _$jscoverage['parse/text.js'][220] = 0;
  _$jscoverage['parse/text.js'][221] = 0;
  _$jscoverage['parse/text.js'][222] = 0;
  _$jscoverage['parse/text.js'][224] = 0;
  _$jscoverage['parse/text.js'][225] = 0;
  _$jscoverage['parse/text.js'][227] = 0;
  _$jscoverage['parse/text.js'][232] = 0;
  _$jscoverage['parse/text.js'][234] = 0;
  _$jscoverage['parse/text.js'][235] = 0;
  _$jscoverage['parse/text.js'][237] = 0;
  _$jscoverage['parse/text.js'][238] = 0;
  _$jscoverage['parse/text.js'][239] = 0;
  _$jscoverage['parse/text.js'][241] = 0;
  _$jscoverage['parse/text.js'][242] = 0;
  _$jscoverage['parse/text.js'][244] = 0;
  _$jscoverage['parse/text.js'][245] = 0;
  _$jscoverage['parse/text.js'][247] = 0;
  _$jscoverage['parse/text.js'][248] = 0;
  _$jscoverage['parse/text.js'][250] = 0;
  _$jscoverage['parse/text.js'][251] = 0;
  _$jscoverage['parse/text.js'][253] = 0;
  _$jscoverage['parse/text.js'][254] = 0;
  _$jscoverage['parse/text.js'][255] = 0;
  _$jscoverage['parse/text.js'][257] = 0;
  _$jscoverage['parse/text.js'][259] = 0;
  _$jscoverage['parse/text.js'][260] = 0;
  _$jscoverage['parse/text.js'][262] = 0;
  _$jscoverage['parse/text.js'][263] = 0;
  _$jscoverage['parse/text.js'][265] = 0;
  _$jscoverage['parse/text.js'][269] = 0;
  _$jscoverage['parse/text.js'][278] = 0;
  _$jscoverage['parse/text.js'][279] = 0;
  _$jscoverage['parse/text.js'][284] = 0;
  _$jscoverage['parse/text.js'][286] = 0;
  _$jscoverage['parse/text.js'][287] = 0;
  _$jscoverage['parse/text.js'][289] = 0;
  _$jscoverage['parse/text.js'][290] = 0;
  _$jscoverage['parse/text.js'][292] = 0;
  _$jscoverage['parse/text.js'][293] = 0;
  _$jscoverage['parse/text.js'][295] = 0;
  _$jscoverage['parse/text.js'][296] = 0;
  _$jscoverage['parse/text.js'][298] = 0;
  _$jscoverage['parse/text.js'][299] = 0;
  _$jscoverage['parse/text.js'][301] = 0;
  _$jscoverage['parse/text.js'][302] = 0;
  _$jscoverage['parse/text.js'][304] = 0;
  _$jscoverage['parse/text.js'][305] = 0;
  _$jscoverage['parse/text.js'][307] = 0;
  _$jscoverage['parse/text.js'][308] = 0;
  _$jscoverage['parse/text.js'][310] = 0;
  _$jscoverage['parse/text.js'][311] = 0;
  _$jscoverage['parse/text.js'][313] = 0;
  _$jscoverage['parse/text.js'][314] = 0;
  _$jscoverage['parse/text.js'][316] = 0;
  _$jscoverage['parse/text.js'][317] = 0;
  _$jscoverage['parse/text.js'][319] = 0;
  _$jscoverage['parse/text.js'][322] = 0;
  _$jscoverage['parse/text.js'][331] = 0;
  _$jscoverage['parse/text.js'][332] = 0;
  _$jscoverage['parse/text.js'][333] = 0;
  _$jscoverage['parse/text.js'][334] = 0;
  _$jscoverage['parse/text.js'][336] = 0;
  _$jscoverage['parse/text.js'][344] = 0;
  _$jscoverage['parse/text.js'][345] = 0;
  _$jscoverage['parse/text.js'][346] = 0;
  _$jscoverage['parse/text.js'][347] = 0;
  _$jscoverage['parse/text.js'][350] = 0;
  _$jscoverage['parse/text.js'][352] = 0;
  _$jscoverage['parse/text.js'][360] = 0;
  _$jscoverage['parse/text.js'][361] = 0;
  _$jscoverage['parse/text.js'][371] = 0;
  _$jscoverage['parse/text.js'][372] = 0;
  _$jscoverage['parse/text.js'][374] = 0;
  _$jscoverage['parse/text.js'][376] = 0;
  _$jscoverage['parse/text.js'][380] = 0;
  _$jscoverage['parse/text.js'][381] = 0;
  _$jscoverage['parse/text.js'][384] = 0;
  _$jscoverage['parse/text.js'][385] = 0;
  _$jscoverage['parse/text.js'][389] = 0;
  _$jscoverage['parse/text.js'][390] = 0;
  _$jscoverage['parse/text.js'][393] = 0;
  _$jscoverage['parse/text.js'][396] = 0;
  _$jscoverage['parse/text.js'][406] = 0;
}
_$jscoverage['parse/text.js'].source = ["/**","* Parses an English string expression and produces a schedule that is","* compatible with Later.js.","*","* Examples:","*","* every 5 minutes between the 1st and 30th minute","* at 10:00 am on tues of may in 2012","* on the 15-20th day of march-dec","* every 20 seconds every 5 minutes every 4 hours between the 10th and 20th hour","*/","later.parse.text = function () {","","  var recur = later.parse.recur,","      pos = 0,","      input = '',","      error;","","  // Regex expressions for all of the valid tokens","  var TOKENTYPES = {","        eof: /^$/,","        rank: /^((\\d\\d\\d\\d)|([2-5]?1(st)?|[2-5]?2(nd)?|[2-5]?3(rd)?|(0|[1-5]?[4-9]|[1-5]0|1[1-3])(th)?))\\b/,","        time: /^((([0]?[1-9]|1[0-2]):[0-5]\\d(\\s)?(am|pm))|(([0]?\\d|1\\d|2[0-3]):[0-5]\\d))\\b/,","        dayName: /^((sun|mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?)(day)?)\\b/,","        monthName: /^(jan(uary)?|feb(ruary)?|ma((r(ch)?)?|y)|apr(il)?|ju(ly|ne)|aug(ust)?|oct(ober)?|(sept|nov|dec)(ember)?)\\b/,","        yearIndex: /^(\\d\\d\\d\\d)\\b/,","        every: /^every\\b/,","        after: /^after\\b/,","        second: /^(s|sec(ond)?(s)?)\\b/,","        minute: /^(m|min(ute)?(s)?)\\b/,","        hour: /^(h|hour(s)?)\\b/,","        day: /^(day(s)?( of the month)?)\\b/,","        dayInstance: /^day instance\\b/,","        dayOfWeek: /^day(s)? of the week\\b/,","        dayOfYear: /^day(s)? of the year\\b/,","        weekOfYear: /^week(s)?( of the year)?\\b/,","        weekOfMonth: /^week(s)? of the month\\b/,","        weekday: /^weekday\\b/,","        weekend: /^weekend\\b/,","        month: /^month(s)?\\b/,","        year: /^year(s)?\\b/,","        between: /^between (the)?\\b/,","        start: /^(start(ing)? (at|on( the)?)?)\\b/,","        at: /^(at|@)\\b/,","        and: /^(,|and\\b)/,","        except: /^(except\\b)/,","        also: /(also)\\b/,","        first: /^(first)\\b/,","        last: /^last\\b/,","        \"in\": /^in\\b/,","        of: /^of\\b/,","        onthe: /^on the\\b/,","        on: /^on\\b/,","        through: /(-|^(to|through)\\b)/","      };","","  // Array to convert string names to valid numerical values","  var NAMES = { jan: 1, feb: 2, mar: 3, apr: 4, may: 5, jun: 6, jul: 7,","        aug: 8, sep: 9, oct: 10, nov: 11, dec: 12, sun: 1, mon: 2, tue: 3,","        wed: 4, thu: 5, fri: 6, sat: 7, '1st': 1, fir: 1, '2nd': 2, sec: 2,","        '3rd': 3, thi: 3, '4th': 4, 'for': 4","      };","","  /**","  * Bundles up the results of the peek operation into a token.","  *","  * @param {Int} start: The start position of the token","  * @param {Int} end: The end position of the token","  * @param {String} text: The actual text that was parsed","  * @param {TokenType} type: The TokenType of the token","  */","  function t(start, end, text, type) {","    return {startPos: start, endPos: end, text: text, type: type};","  }","","  /**","  * Peeks forward to see if the next token is the expected token and","  * returns the token if found.  Pos is not moved during a Peek operation.","  *","  * @param {TokenType} exepected: The types of token to scan for","  */","  function peek(expected) {","    var scanTokens = expected instanceof Array ? expected : [expected],","        whiteSpace = /\\s+/,","        token, curInput, m, scanToken, start, len;","","    scanTokens.push(whiteSpace);","","    // loop past any skipped tokens and only look for expected tokens","    start = pos;","    while (!token || token.type === whiteSpace) {","      len = -1;","      curInput = input.substring(start);","      token = t(start, start, input.split(whiteSpace)[0]);","","      var i, length = scanTokens.length;","      for(i = 0; i &lt; length; i++) {","        scanToken = scanTokens[i];","        m = scanToken.exec(curInput);","        if (m &amp;&amp; m.index === 0 &amp;&amp; m[0].length &gt; len) {","          len = m[0].length;","          token = t(start, start + len, curInput.substring(0, len), scanToken);","        }","      }","","      // update the start position if this token should be skipped","      if (token.type === whiteSpace) {","        start = token.endPos;","      }","    }","","    return token;","  }","","  /**","  * Moves pos to the end of the expectedToken if it is found.","  *","  * @param {TokenType} exepectedToken: The types of token to scan for","  */","  function scan(expectedToken) {","    var token = peek(expectedToken);","    pos = token.endPos;","    return token;","  }","","  /**","  * Parses the next 'y-z' expression and returns the resulting valid","  * value array.","  *","  * @param {TokenType} tokenType: The type of range values allowed","  */","  function parseThroughExpr(tokenType) {","    var start = +parseTokenValue(tokenType),","        end = checkAndParse(TOKENTYPES.through) ? +parseTokenValue(tokenType) : start,","        nums = [];","","    for (var i = start; i &lt;= end; i++) {","      nums.push(i);","    }","","    return nums;","  }","","  /**","  * Parses the next 'x,y-z' expression and returns the resulting valid","  * value array.","  *","  * @param {TokenType} tokenType: The type of range values allowed","  */","  function parseRanges(tokenType) {","    var nums = parseThroughExpr(tokenType);","    while (checkAndParse(TOKENTYPES.and)) {","      nums = nums.concat(parseThroughExpr(tokenType));","    }","    return nums;","  }","","  /**","  * Parses the next 'every (weekend|weekday|x) (starting on|between)' expression.","  *","  * @param {Recur} r: The recurrence to add the expression to","  */","  function parseEvery(r) {","    var num, period, start, end;","","    if (checkAndParse(TOKENTYPES.weekend)) {","      r.on(NAMES.sun,NAMES.sat).dayOfWeek();","    }","    else if (checkAndParse(TOKENTYPES.weekday)) {","      r.on(NAMES.mon,NAMES.tue,NAMES.wed,NAMES.thu,NAMES.fri).dayOfWeek();","    }","    else {","      num = parseTokenValue(TOKENTYPES.rank);","      r.every(num);","      period = parseTimePeriod(r);","","      if (checkAndParse(TOKENTYPES.start)) {","        num = parseTokenValue(TOKENTYPES.rank);","        r.startingOn(num);","        parseToken(period.type);","      }","      else if (checkAndParse(TOKENTYPES.between)) {","        start = parseTokenValue(TOKENTYPES.rank);","        if (checkAndParse(TOKENTYPES.and)) {","          end = parseTokenValue(TOKENTYPES.rank);","          r.between(start,end);","        }","      }","    }","  }","","  /**","  * Parses the next 'on the (first|last|x,y-z)' expression.","  *","  * @param {Recur} r: The recurrence to add the expression to","  */","  function parseOnThe(r) {","    if (checkAndParse(TOKENTYPES.first)) {","      r.first();","    }","    else if (checkAndParse(TOKENTYPES.last)) {","      r.last();","    }","    else {","      r.on(parseRanges(TOKENTYPES.rank));","    }","","    parseTimePeriod(r);","  }","","  /**","  * Parses the schedule expression and returns the resulting schedules,","  * and exceptions.  Error will return the position in the string where","  * an error occurred, will be null if no errors were found in the","  * expression.","  *","  * @param {String} str: The schedule expression to parse","  */","  function parseScheduleExpr(str) {","    pos = 0;","    input = str;","    error = -1;","","    var r = recur();","    while (pos &lt; input.length &amp;&amp; error &lt; 0) {","","      var token = parseToken([TOKENTYPES.every, TOKENTYPES.after,","            TOKENTYPES.onthe, TOKENTYPES.on, TOKENTYPES.of, TOKENTYPES[\"in\"],","            TOKENTYPES.at, TOKENTYPES.and, TOKENTYPES.except,","            TOKENTYPES.also]);","","      switch (token.type) {","        case TOKENTYPES.every:","          parseEvery(r);","          break;","        case TOKENTYPES.after:","          r.after(parseTokenValue(TOKENTYPES.rank));","          parseTimePeriod(r);","          break;","        case TOKENTYPES.onthe:","          parseOnThe(r);","          break;","        case TOKENTYPES.on:","          r.on(parseRanges(TOKENTYPES.dayName)).dayOfWeek();","          break;","        case TOKENTYPES.of:","          r.on(parseRanges(TOKENTYPES.monthName)).month();","          break;","        case TOKENTYPES[\"in\"]:","          r.on(parseRanges(TOKENTYPES.yearIndex)).year();","          break;","        case TOKENTYPES.at:","          r.at(parseTokenValue(TOKENTYPES.time));","          while (checkAndParse(TOKENTYPES.and)) {","            r.at(parseTokenValue(TOKENTYPES.time));","          }","          break;","        case TOKENTYPES.also:","          r.and();","          break;","        case TOKENTYPES.except:","          r.except();","          break;","        default:","          error = pos;","      }","    }","","    return {schedules: r.schedules, exceptions: r.exceptions, error: error};","  }","","  /**","  * Parses the next token representing a time period and adds it to","  * the provided recur object.","  *","  * @param {Recur} r: The recurrence to add the time period to","  */","  function parseTimePeriod(r) {","    var timePeriod = parseToken([TOKENTYPES.second, TOKENTYPES.minute,","          TOKENTYPES.hour, TOKENTYPES.dayOfYear, TOKENTYPES.dayOfWeek,","          TOKENTYPES.dayInstance, TOKENTYPES.day, TOKENTYPES.month,","          TOKENTYPES.year, TOKENTYPES.weekOfMonth, TOKENTYPES.weekOfYear]);","","    switch (timePeriod.type) {","      case TOKENTYPES.second:","        r.second();","        break;","      case TOKENTYPES.minute:","        r.minute();","        break;","      case TOKENTYPES.hour:","        r.hour();","        break;","      case TOKENTYPES.dayOfYear:","        r.dayOfYear();","        break;","      case TOKENTYPES.dayOfWeek:","        r.dayOfWeek();","        break;","      case TOKENTYPES.dayInstance:","        r.dayOfWeekCount();","        break;","      case TOKENTYPES.day:","        r.dayOfMonth();","        break;","      case TOKENTYPES.weekOfMonth:","        r.weekOfMonth();","        break;","      case TOKENTYPES.weekOfYear:","        r.weekOfYear();","        break;","      case TOKENTYPES.month:","        r.month();","        break;","      case TOKENTYPES.year:","        r.year();","        break;","      default:","        error = pos;","    }","","    return timePeriod;","  }","","  /**","  * Checks the next token to see if it is of tokenType. Returns true if","  * it is and discards the token.  Returns false otherwise.","  *","  * @param {TokenType} tokenType: The type or types of token to parse","  */","  function checkAndParse(tokenType) {","    var found = (peek(tokenType)).type === tokenType;","    if (found) {","      scan(tokenType);","    }","    return found;","  }","","  /**","  * Parses and returns the next token.","  *","  * @param {TokenType} tokenType: The type or types of token to parse","  */","  function parseToken(tokenType) {","    var t = scan(tokenType);","    if (t.type) {","      t.text = convertString(t.text, tokenType);","    }","    else {","      error = pos;","    }","    return t;","  }","","  /**","  * Returns the text value of the token that was parsed.","  *","  * @param {TokenType} tokenType: The type of token to parse","  */","  function parseTokenValue(tokenType) {","    return (parseToken(tokenType)).text;","  }","","  /**","  * Converts a string value to a numerical value based on the type of","  * token that was parsed.","  *","  * @param {String} str: The schedule string to parse","  * @param {TokenType} tokenType: The type of token to convert","  */","  function convertString(str, tokenType) {","    var output = str;","","    switch (tokenType) {","      case TOKENTYPES.time:","        var parts = str.split(/(:|am|pm)/),","            hour = parts[3] === 'pm' ? parseInt(parts[0],10) + 12 : parts[0],","            min = parts[2].trim();","","        output = (hour.length === 1 ? '0' : '') + hour + \":\" + min;","        break;","","      case TOKENTYPES.rank:","        output = parseInt((/^\\d+/.exec(str))[0],10);","        break;","","      case TOKENTYPES.monthName:","      case TOKENTYPES.dayName:","        output = NAMES[str.substring(0,3)];","        break;","    }","","    return output;","  }","","  return {","","    /**","    * Parses a schedule string.  Returns the schedule, exceptions, and","    * an error position if an error was hit.","    *","    * @param {String} str: The schedule string to parse","    * @api public","    */","    parse: function(str) {","      return parseScheduleExpr(str.toLowerCase());","    }","  };","};"];
_$jscoverage['parse/text.js'][12]++;
later.parse.text = (function () {
  _$jscoverage['parse/text.js'][14]++;
  var recur = later.parse.recur, pos = 0, input = "", error;
  _$jscoverage['parse/text.js'][20]++;
  var TOKENTYPES = {eof: /^$/, rank: /^((\d\d\d\d)|([2-5]?1(st)?|[2-5]?2(nd)?|[2-5]?3(rd)?|(0|[1-5]?[4-9]|[1-5]0|1[1-3])(th)?))\b/, time: /^((([0]?[1-9]|1[0-2]):[0-5]\d(\s)?(am|pm))|(([0]?\d|1\d|2[0-3]):[0-5]\d))\b/, dayName: /^((sun|mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?)(day)?)\b/, monthName: /^(jan(uary)?|feb(ruary)?|ma((r(ch)?)?|y)|apr(il)?|ju(ly|ne)|aug(ust)?|oct(ober)?|(sept|nov|dec)(ember)?)\b/, yearIndex: /^(\d\d\d\d)\b/, every: /^every\b/, after: /^after\b/, second: /^(s|sec(ond)?(s)?)\b/, minute: /^(m|min(ute)?(s)?)\b/, hour: /^(h|hour(s)?)\b/, day: /^(day(s)?( of the month)?)\b/, dayInstance: /^day instance\b/, dayOfWeek: /^day(s)? of the week\b/, dayOfYear: /^day(s)? of the year\b/, weekOfYear: /^week(s)?( of the year)?\b/, weekOfMonth: /^week(s)? of the month\b/, weekday: /^weekday\b/, weekend: /^weekend\b/, month: /^month(s)?\b/, year: /^year(s)?\b/, between: /^between (the)?\b/, start: /^(start(ing)? (at|on( the)?)?)\b/, at: /^(at|@)\b/, and: /^(,|and\b)/, except: /^(except\b)/, also: /(also)\b/, first: /^(first)\b/, last: /^last\b/, "in": /^in\b/, of: /^of\b/, onthe: /^on the\b/, on: /^on\b/, through: /(-|^(to|through)\b)/};
  _$jscoverage['parse/text.js'][58]++;
  var NAMES = {jan: 1, feb: 2, mar: 3, apr: 4, may: 5, jun: 6, jul: 7, aug: 8, sep: 9, oct: 10, nov: 11, dec: 12, sun: 1, mon: 2, tue: 3, wed: 4, thu: 5, fri: 6, sat: 7, "1st": 1, fir: 1, "2nd": 2, sec: 2, "3rd": 3, thi: 3, "4th": 4, "for": 4};
  _$jscoverage['parse/text.js'][72]++;
  function t(start, end, text, type) {
    _$jscoverage['parse/text.js'][73]++;
    return ({startPos: start, endPos: end, text: text, type: type});
}
  _$jscoverage['parse/text.js'][82]++;
  function peek(expected) {
    _$jscoverage['parse/text.js'][83]++;
    var scanTokens = ((expected instanceof Array)? expected: [expected]), whiteSpace = /\s+/, token, curInput, m, scanToken, start, len;
    _$jscoverage['parse/text.js'][87]++;
    scanTokens.push(whiteSpace);
    _$jscoverage['parse/text.js'][90]++;
    start = pos;
    _$jscoverage['parse/text.js'][91]++;
    while (((! token) || (token.type === whiteSpace))) {
      _$jscoverage['parse/text.js'][92]++;
      len = -1;
      _$jscoverage['parse/text.js'][93]++;
      curInput = input.substring(start);
      _$jscoverage['parse/text.js'][94]++;
      token = t(start, start, input.split(whiteSpace)[0]);
      _$jscoverage['parse/text.js'][96]++;
      var i, length = scanTokens.length;
      _$jscoverage['parse/text.js'][97]++;
      for (i = 0; (i < length); (i++)) {
        _$jscoverage['parse/text.js'][98]++;
        scanToken = scanTokens[i];
        _$jscoverage['parse/text.js'][99]++;
        m = scanToken.exec(curInput);
        _$jscoverage['parse/text.js'][100]++;
        if ((m && (m.index === 0) && (m[0].length > len))) {
          _$jscoverage['parse/text.js'][101]++;
          len = m[0].length;
          _$jscoverage['parse/text.js'][102]++;
          token = t(start, (start + len), curInput.substring(0, len), scanToken);
        }
}
      _$jscoverage['parse/text.js'][107]++;
      if ((token.type === whiteSpace)) {
        _$jscoverage['parse/text.js'][108]++;
        start = token.endPos;
      }
}
    _$jscoverage['parse/text.js'][112]++;
    return token;
}
  _$jscoverage['parse/text.js'][120]++;
  function scan(expectedToken) {
    _$jscoverage['parse/text.js'][121]++;
    var token = peek(expectedToken);
    _$jscoverage['parse/text.js'][122]++;
    pos = token.endPos;
    _$jscoverage['parse/text.js'][123]++;
    return token;
}
  _$jscoverage['parse/text.js'][132]++;
  function parseThroughExpr(tokenType) {
    _$jscoverage['parse/text.js'][133]++;
    var start = (+ parseTokenValue(tokenType)), end = (checkAndParse(TOKENTYPES.through)? (+ parseTokenValue(tokenType)): start), nums = [];
    _$jscoverage['parse/text.js'][137]++;
    for (var i = start; (i <= end); (i++)) {
      _$jscoverage['parse/text.js'][138]++;
      nums.push(i);
}
    _$jscoverage['parse/text.js'][141]++;
    return nums;
}
  _$jscoverage['parse/text.js'][150]++;
  function parseRanges(tokenType) {
    _$jscoverage['parse/text.js'][151]++;
    var nums = parseThroughExpr(tokenType);
    _$jscoverage['parse/text.js'][152]++;
    while (checkAndParse(TOKENTYPES.and)) {
      _$jscoverage['parse/text.js'][153]++;
      nums = nums.concat(parseThroughExpr(tokenType));
}
    _$jscoverage['parse/text.js'][155]++;
    return nums;
}
  _$jscoverage['parse/text.js'][163]++;
  function parseEvery(r) {
    _$jscoverage['parse/text.js'][164]++;
    var num, period, start, end;
    _$jscoverage['parse/text.js'][166]++;
    if (checkAndParse(TOKENTYPES.weekend)) {
      _$jscoverage['parse/text.js'][167]++;
      r.on(NAMES.sun, NAMES.sat).dayOfWeek();
    }
    else {
      _$jscoverage['parse/text.js'][169]++;
      if (checkAndParse(TOKENTYPES.weekday)) {
        _$jscoverage['parse/text.js'][170]++;
        r.on(NAMES.mon, NAMES.tue, NAMES.wed, NAMES.thu, NAMES.fri).dayOfWeek();
      }
      else {
        _$jscoverage['parse/text.js'][173]++;
        num = parseTokenValue(TOKENTYPES.rank);
        _$jscoverage['parse/text.js'][174]++;
        r.every(num);
        _$jscoverage['parse/text.js'][175]++;
        period = parseTimePeriod(r);
        _$jscoverage['parse/text.js'][177]++;
        if (checkAndParse(TOKENTYPES.start)) {
          _$jscoverage['parse/text.js'][178]++;
          num = parseTokenValue(TOKENTYPES.rank);
          _$jscoverage['parse/text.js'][179]++;
          r.startingOn(num);
          _$jscoverage['parse/text.js'][180]++;
          parseToken(period.type);
        }
        else {
          _$jscoverage['parse/text.js'][182]++;
          if (checkAndParse(TOKENTYPES.between)) {
            _$jscoverage['parse/text.js'][183]++;
            start = parseTokenValue(TOKENTYPES.rank);
            _$jscoverage['parse/text.js'][184]++;
            if (checkAndParse(TOKENTYPES.and)) {
              _$jscoverage['parse/text.js'][185]++;
              end = parseTokenValue(TOKENTYPES.rank);
              _$jscoverage['parse/text.js'][186]++;
              r.between(start, end);
            }
          }
        }
      }
    }
}
  _$jscoverage['parse/text.js'][197]++;
  function parseOnThe(r) {
    _$jscoverage['parse/text.js'][198]++;
    if (checkAndParse(TOKENTYPES.first)) {
      _$jscoverage['parse/text.js'][199]++;
      r.first();
    }
    else {
      _$jscoverage['parse/text.js'][201]++;
      if (checkAndParse(TOKENTYPES.last)) {
        _$jscoverage['parse/text.js'][202]++;
        r.last();
      }
      else {
        _$jscoverage['parse/text.js'][205]++;
        r.on(parseRanges(TOKENTYPES.rank));
      }
    }
    _$jscoverage['parse/text.js'][208]++;
    parseTimePeriod(r);
}
  _$jscoverage['parse/text.js'][219]++;
  function parseScheduleExpr(str) {
    _$jscoverage['parse/text.js'][220]++;
    pos = 0;
    _$jscoverage['parse/text.js'][221]++;
    input = str;
    _$jscoverage['parse/text.js'][222]++;
    error = -1;
    _$jscoverage['parse/text.js'][224]++;
    var r = recur();
    _$jscoverage['parse/text.js'][225]++;
    while (((pos < input.length) && (error < 0))) {
      _$jscoverage['parse/text.js'][227]++;
      var token = parseToken([TOKENTYPES.every, TOKENTYPES.after, TOKENTYPES.onthe, TOKENTYPES.on, TOKENTYPES.of, TOKENTYPES["in"], TOKENTYPES.at, TOKENTYPES.and, TOKENTYPES.except, TOKENTYPES.also]);
      _$jscoverage['parse/text.js'][232]++;
      switch (token.type) {
      case TOKENTYPES.every:
        _$jscoverage['parse/text.js'][234]++;
        parseEvery(r);
        _$jscoverage['parse/text.js'][235]++;
        break;
      case TOKENTYPES.after:
        _$jscoverage['parse/text.js'][237]++;
        r.after(parseTokenValue(TOKENTYPES.rank));
        _$jscoverage['parse/text.js'][238]++;
        parseTimePeriod(r);
        _$jscoverage['parse/text.js'][239]++;
        break;
      case TOKENTYPES.onthe:
        _$jscoverage['parse/text.js'][241]++;
        parseOnThe(r);
        _$jscoverage['parse/text.js'][242]++;
        break;
      case TOKENTYPES.on:
        _$jscoverage['parse/text.js'][244]++;
        r.on(parseRanges(TOKENTYPES.dayName)).dayOfWeek();
        _$jscoverage['parse/text.js'][245]++;
        break;
      case TOKENTYPES.of:
        _$jscoverage['parse/text.js'][247]++;
        r.on(parseRanges(TOKENTYPES.monthName)).month();
        _$jscoverage['parse/text.js'][248]++;
        break;
      case TOKENTYPES["in"]:
        _$jscoverage['parse/text.js'][250]++;
        r.on(parseRanges(TOKENTYPES.yearIndex)).year();
        _$jscoverage['parse/text.js'][251]++;
        break;
      case TOKENTYPES.at:
        _$jscoverage['parse/text.js'][253]++;
        r.at(parseTokenValue(TOKENTYPES.time));
        _$jscoverage['parse/text.js'][254]++;
        while (checkAndParse(TOKENTYPES.and)) {
          _$jscoverage['parse/text.js'][255]++;
          r.at(parseTokenValue(TOKENTYPES.time));
}
        _$jscoverage['parse/text.js'][257]++;
        break;
      case TOKENTYPES.also:
        _$jscoverage['parse/text.js'][259]++;
        r.and();
        _$jscoverage['parse/text.js'][260]++;
        break;
      case TOKENTYPES.except:
        _$jscoverage['parse/text.js'][262]++;
        r.except();
        _$jscoverage['parse/text.js'][263]++;
        break;
      default:
        _$jscoverage['parse/text.js'][265]++;
        error = pos;
      }
}
    _$jscoverage['parse/text.js'][269]++;
    return ({schedules: r.schedules, exceptions: r.exceptions, error: error});
}
  _$jscoverage['parse/text.js'][278]++;
  function parseTimePeriod(r) {
    _$jscoverage['parse/text.js'][279]++;
    var timePeriod = parseToken([TOKENTYPES.second, TOKENTYPES.minute, TOKENTYPES.hour, TOKENTYPES.dayOfYear, TOKENTYPES.dayOfWeek, TOKENTYPES.dayInstance, TOKENTYPES.day, TOKENTYPES.month, TOKENTYPES.year, TOKENTYPES.weekOfMonth, TOKENTYPES.weekOfYear]);
    _$jscoverage['parse/text.js'][284]++;
    switch (timePeriod.type) {
    case TOKENTYPES.second:
      _$jscoverage['parse/text.js'][286]++;
      r.second();
      _$jscoverage['parse/text.js'][287]++;
      break;
    case TOKENTYPES.minute:
      _$jscoverage['parse/text.js'][289]++;
      r.minute();
      _$jscoverage['parse/text.js'][290]++;
      break;
    case TOKENTYPES.hour:
      _$jscoverage['parse/text.js'][292]++;
      r.hour();
      _$jscoverage['parse/text.js'][293]++;
      break;
    case TOKENTYPES.dayOfYear:
      _$jscoverage['parse/text.js'][295]++;
      r.dayOfYear();
      _$jscoverage['parse/text.js'][296]++;
      break;
    case TOKENTYPES.dayOfWeek:
      _$jscoverage['parse/text.js'][298]++;
      r.dayOfWeek();
      _$jscoverage['parse/text.js'][299]++;
      break;
    case TOKENTYPES.dayInstance:
      _$jscoverage['parse/text.js'][301]++;
      r.dayOfWeekCount();
      _$jscoverage['parse/text.js'][302]++;
      break;
    case TOKENTYPES.day:
      _$jscoverage['parse/text.js'][304]++;
      r.dayOfMonth();
      _$jscoverage['parse/text.js'][305]++;
      break;
    case TOKENTYPES.weekOfMonth:
      _$jscoverage['parse/text.js'][307]++;
      r.weekOfMonth();
      _$jscoverage['parse/text.js'][308]++;
      break;
    case TOKENTYPES.weekOfYear:
      _$jscoverage['parse/text.js'][310]++;
      r.weekOfYear();
      _$jscoverage['parse/text.js'][311]++;
      break;
    case TOKENTYPES.month:
      _$jscoverage['parse/text.js'][313]++;
      r.month();
      _$jscoverage['parse/text.js'][314]++;
      break;
    case TOKENTYPES.year:
      _$jscoverage['parse/text.js'][316]++;
      r.year();
      _$jscoverage['parse/text.js'][317]++;
      break;
    default:
      _$jscoverage['parse/text.js'][319]++;
      error = pos;
    }
    _$jscoverage['parse/text.js'][322]++;
    return timePeriod;
}
  _$jscoverage['parse/text.js'][331]++;
  function checkAndParse(tokenType) {
    _$jscoverage['parse/text.js'][332]++;
    var found = (peek(tokenType).type === tokenType);
    _$jscoverage['parse/text.js'][333]++;
    if (found) {
      _$jscoverage['parse/text.js'][334]++;
      scan(tokenType);
    }
    _$jscoverage['parse/text.js'][336]++;
    return found;
}
  _$jscoverage['parse/text.js'][344]++;
  function parseToken(tokenType) {
    _$jscoverage['parse/text.js'][345]++;
    var t = scan(tokenType);
    _$jscoverage['parse/text.js'][346]++;
    if (t.type) {
      _$jscoverage['parse/text.js'][347]++;
      t.text = convertString(t.text, tokenType);
    }
    else {
      _$jscoverage['parse/text.js'][350]++;
      error = pos;
    }
    _$jscoverage['parse/text.js'][352]++;
    return t;
}
  _$jscoverage['parse/text.js'][360]++;
  function parseTokenValue(tokenType) {
    _$jscoverage['parse/text.js'][361]++;
    return parseToken(tokenType).text;
}
  _$jscoverage['parse/text.js'][371]++;
  function convertString(str, tokenType) {
    _$jscoverage['parse/text.js'][372]++;
    var output = str;
    _$jscoverage['parse/text.js'][374]++;
    switch (tokenType) {
    case TOKENTYPES.time:
      _$jscoverage['parse/text.js'][376]++;
      var parts = str.split(/(:|am|pm)/), hour = ((parts[3] === "pm")? (parseInt(parts[0], 10) + 12): parts[0]), min = parts[2].trim();
      _$jscoverage['parse/text.js'][380]++;
      output = (((hour.length === 1)? "0": "") + hour + ":" + min);
      _$jscoverage['parse/text.js'][381]++;
      break;
    case TOKENTYPES.rank:
      _$jscoverage['parse/text.js'][384]++;
      output = parseInt(/^\d+/.exec(str)[0], 10);
      _$jscoverage['parse/text.js'][385]++;
      break;
    case TOKENTYPES.monthName:
    case TOKENTYPES.dayName:
      _$jscoverage['parse/text.js'][389]++;
      output = NAMES[str.substring(0, 3)];
      _$jscoverage['parse/text.js'][390]++;
      break;
    }
    _$jscoverage['parse/text.js'][393]++;
    return output;
}
  _$jscoverage['parse/text.js'][396]++;
  return ({parse: (function (str) {
  _$jscoverage['parse/text.js'][406]++;
  return parseScheduleExpr(str.toLowerCase());
})});
});
