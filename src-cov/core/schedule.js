/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['core/schedule.js']) {
  _$jscoverage['core/schedule.js'] = [];
  _$jscoverage['core/schedule.js'][12] = 0;
  _$jscoverage['core/schedule.js'][13] = 0;
  _$jscoverage['core/schedule.js'][14] = 0;
  _$jscoverage['core/schedule.js'][17] = 0;
  _$jscoverage['core/schedule.js'][22] = 0;
  _$jscoverage['core/schedule.js'][23] = 0;
  _$jscoverage['core/schedule.js'][26] = 0;
  _$jscoverage['core/schedule.js'][27] = 0;
  _$jscoverage['core/schedule.js'][40] = 0;
  _$jscoverage['core/schedule.js'][41] = 0;
  _$jscoverage['core/schedule.js'][46] = 0;
  _$jscoverage['core/schedule.js'][47] = 0;
  _$jscoverage['core/schedule.js'][50] = 0;
  _$jscoverage['core/schedule.js'][52] = 0;
  _$jscoverage['core/schedule.js'][55] = 0;
  _$jscoverage['core/schedule.js'][56] = 0;
  _$jscoverage['core/schedule.js'][57] = 0;
  _$jscoverage['core/schedule.js'][61] = 0;
  _$jscoverage['core/schedule.js'][62] = 0;
  _$jscoverage['core/schedule.js'][67] = 0;
  _$jscoverage['core/schedule.js'][68] = 0;
  _$jscoverage['core/schedule.js'][69] = 0;
  _$jscoverage['core/schedule.js'][70] = 0;
  _$jscoverage['core/schedule.js'][71] = 0;
  _$jscoverage['core/schedule.js'][77] = 0;
  _$jscoverage['core/schedule.js'][78] = 0;
  _$jscoverage['core/schedule.js'][79] = 0;
  _$jscoverage['core/schedule.js'][83] = 0;
  _$jscoverage['core/schedule.js'][84] = 0;
  _$jscoverage['core/schedule.js'][87] = 0;
  _$jscoverage['core/schedule.js'][88] = 0;
  _$jscoverage['core/schedule.js'][91] = 0;
  _$jscoverage['core/schedule.js'][94] = 0;
  _$jscoverage['core/schedule.js'][107] = 0;
  _$jscoverage['core/schedule.js'][108] = 0;
  _$jscoverage['core/schedule.js'][110] = 0;
  _$jscoverage['core/schedule.js'][111] = 0;
  _$jscoverage['core/schedule.js'][112] = 0;
  _$jscoverage['core/schedule.js'][127] = 0;
  _$jscoverage['core/schedule.js'][128] = 0;
  _$jscoverage['core/schedule.js'][130] = 0;
  _$jscoverage['core/schedule.js'][131] = 0;
  _$jscoverage['core/schedule.js'][132] = 0;
  _$jscoverage['core/schedule.js'][133] = 0;
  _$jscoverage['core/schedule.js'][147] = 0;
  _$jscoverage['core/schedule.js'][148] = 0;
  _$jscoverage['core/schedule.js'][149] = 0;
  _$jscoverage['core/schedule.js'][150] = 0;
  _$jscoverage['core/schedule.js'][164] = 0;
  _$jscoverage['core/schedule.js'][165] = 0;
  _$jscoverage['core/schedule.js'][167] = 0;
  _$jscoverage['core/schedule.js'][168] = 0;
  _$jscoverage['core/schedule.js'][169] = 0;
  _$jscoverage['core/schedule.js'][172] = 0;
  _$jscoverage['core/schedule.js'][178] = 0;
  _$jscoverage['core/schedule.js'][179] = 0;
  _$jscoverage['core/schedule.js'][180] = 0;
  _$jscoverage['core/schedule.js'][185] = 0;
  _$jscoverage['core/schedule.js'][198] = 0;
  _$jscoverage['core/schedule.js'][199] = 0;
  _$jscoverage['core/schedule.js'][201] = 0;
  _$jscoverage['core/schedule.js'][202] = 0;
  _$jscoverage['core/schedule.js'][203] = 0;
  _$jscoverage['core/schedule.js'][205] = 0;
  _$jscoverage['core/schedule.js'][208] = 0;
  _$jscoverage['core/schedule.js'][209] = 0;
  _$jscoverage['core/schedule.js'][213] = 0;
  _$jscoverage['core/schedule.js'][214] = 0;
  _$jscoverage['core/schedule.js'][218] = 0;
  _$jscoverage['core/schedule.js'][228] = 0;
  _$jscoverage['core/schedule.js'][229] = 0;
  _$jscoverage['core/schedule.js'][230] = 0;
  _$jscoverage['core/schedule.js'][231] = 0;
  _$jscoverage['core/schedule.js'][241] = 0;
  _$jscoverage['core/schedule.js'][242] = 0;
  _$jscoverage['core/schedule.js'][244] = 0;
  _$jscoverage['core/schedule.js'][245] = 0;
  _$jscoverage['core/schedule.js'][246] = 0;
  _$jscoverage['core/schedule.js'][250] = 0;
  _$jscoverage['core/schedule.js'][254] = 0;
  _$jscoverage['core/schedule.js'][262] = 0;
  _$jscoverage['core/schedule.js'][276] = 0;
  _$jscoverage['core/schedule.js'][290] = 0;
  _$jscoverage['core/schedule.js'][304] = 0;
  _$jscoverage['core/schedule.js'][318] = 0;
}
_$jscoverage['core/schedule.js'].source = ["/**","* Schedule","* (c) 2013 Bill, BunKat LLC.","*","* Returns an object to calculate future or previous occurrences of the","* specified schedule.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","later.schedule = function(sched) {","  if(!sched) throw new Error('Missing schedule definition.');","  if(!sched.schedules) throw new Error('Definition must include at least one schedule.');","","  // compile the schedule components","  var schedules = [],","      schedulesLen = sched.schedules.length,","      exceptions = [],","      exceptionsLen = sched.exceptions ? sched.exceptions.length : 0;","","  for(var i = 0; i &lt; schedulesLen; i++) {","    schedules.push(later.compile(sched.schedules[i]));","  }","","  for(var j = 0; j &lt; exceptionsLen; j++) {","    exceptions.push(later.compile(sched.exceptions[j]));","  }","","  /**","  * Calculates count number of instances or ranges for the current schedule,","  * optionally between the specified startDate and endDate.","  *","  * @param {String} dir: The direction to use, either 'next' or 'prev'","  * @param {Integer} count: The number of instances or ranges to return","  * @param {Date} startDate: The earliest date a valid instance can occur on","  * @param {Date} endDate: The latest date a valid instance can occur on","  * @param {Bool} isRange: True to return ranges, false to return instances","  */","  function getInstances(dir, count, startDate, endDate, isRange) {","    var compare = compareFn(dir), // encapsulates difference between directions","        loopCount = count,","        schedStarts = [], exceptStarts = [],","        next, end, results = [];","","    startDate = startDate ? new Date(startDate) : new Date();","    if(!startDate || !startDate.getTime()) throw new Error('Invalid start date.');","","    // calc the earliest start date for each schedule","    updateNextStarts(dir, schedules, schedStarts, startDate);","","    while(loopCount &amp;&amp; (next = findNext(schedStarts, compare))) {","","      // make sure that we aren't earlier than the startDate","      if(compare(startDate, next)) {","        tickStarts(dir, schedules, schedStarts, next);","        continue;","      }","","      // make sure we didn't go past the end date","      if((endDate &amp;&amp; compare(next, endDate))) {","        break;","      }","","      // update the exception start dates based on current value of next","      // and determine if there is any overlap","      if(exceptionsLen) {","        updateRangeStarts(dir, exceptions, exceptStarts, next);","        if((end = calcRangeOverlap(dir, exceptions, exceptStarts, next))) {","          updateNextStarts(dir, schedules, schedStarts, end);","          continue;","        }","      }","","      // next is a valid occurrence, save to results and move to next possible","      // valid occurrence","      if(isRange) {","        end = calcEnd(dir, schedules, schedStarts, next, findNext(exceptStarts, compare));","        results.push([new Date(next), new Date(end)]);","","        // new end is either the end date when going forward, or just before","        // the start date when going backwards","        end = dir === 'next' ? end : new Date(next.getTime()-1000);","        updateNextStarts(dir, schedules, schedStarts, end);","      }","      else {","        results.push(new Date(next));","        tickStarts(dir, schedules, schedStarts, next);","      }","","      loopCount--;","    }","","    return results.length === 0 ? undefined : count === 1 ? results[0] : results;","  }","","  /**","  * Updates the set of cached start dates to the next valid start dates. Only","  * schedules where the current start date is less than or equal to the","  * specified startDate need to be updated.","  *","  * @param {String} dir: The direction to use, either 'next' or 'prev'","  * @param {Array} schedArr: The set of compiled schedules to use","  * @param {Array} startsArr: The set of cached start dates for the schedules","  * @param {Date} startDate: Starts earlier than this date will be calculated","  */","  function updateNextStarts(dir, schedArr, startsArr, startDate) {","    var compare = compareFn(dir);","","    for(var i = 0, len = schedArr.length; i &lt; len; i++) {","      if(!startsArr[i] || !compare(startsArr[i], startDate)) {","        startsArr[i] = schedArr[i].start(dir, startDate);","      }","    }","  }","","  /**","  * Updates the set of cached ranges to the next valid ranges. Only","  * schedules where the current start date is less than or equal to the","  * specified startDate need to be updated.","  *","  * @param {String} dir: The direction to use, either 'next' or 'prev'","  * @param {Array} schedArr: The set of compiled schedules to use","  * @param {Array} startsArr: The set of cached start dates for the schedules","  * @param {Date} startDate: Starts earlier than this date will be calculated","  */","  function updateRangeStarts(dir, schedArr, rangesArr, startDate) {","    var compare = compareFn(dir);","","    for(var i = 0, len = schedArr.length; i &lt; len; i++) {","      if(!rangesArr[i] || !compare(rangesArr[i][0], startDate)) {","        var nextStart = schedArr[i].start(dir, startDate);","        rangesArr[i] = nextStart ? [nextStart, schedArr[i].end(nextStart)] : undefined;","      }","    }","  }","","  /**","  * Increments all schedules with next start equal to startDate by one tick.","  * Tick size is determined by the smallest constraint within a schedule.","  *","  * @param {String} dir: The direction to use, either 'next' or 'prev'","  * @param {Array} schedArr: The set of compiled schedules to use","  * @param {Array} startsArr: The set of cached start dates for the schedules","  * @param {Date} startDate: The date that should cause a schedule to tick","  */","  function tickStarts(dir, schedArr, startsArr, startDate) {","    for(var i = 0, len = schedArr.length; i &lt; len; i++) {","      if(startsArr[i] &amp;&amp; startsArr[i].getTime() === startDate.getTime()) {","        startsArr[i] = schedArr[i].start(dir, schedArr[i].tick(dir, startDate));","      }","    }","  }","","  /**","  * Calculates the end of the overlap between any exception schedule and the","  * specified start date. Returns undefined if there is no overlap.","  *","  * @param {String} dir: The direction to use, either 'next' or 'prev'","  * @param {Array} schedArr: The set of compiled schedules to use","  * @param {Array} rangesArr: The set of cached start dates for the schedules","  * @param {Date} startDate: The valid date for which the overlap will be found","  */","  function calcRangeOverlap(dir, schedArr, rangesArr, startDate) {","    var compare = compareFn(dir), result;","","    for(var i = 0, len = schedArr.length; i &lt; len; i++) {","      var range = rangesArr[i];","      if(!range) continue;","","      // see if startDate falls inside of the range","      if(startDate.getTime() &gt;= range[0].getTime() &amp;&amp;","        (!range[1] || startDate.getTime() &lt; range[1].getTime())) {","","        // end depends on direction, going forwards its the end of the exception","        // schedule; going backwards it is the second immediatley before the","        // start of the exception","        var end = dir === 'next' ? range[1] : new Date(range[0].getTime()-1000);","        if(!result || compare(end, result)) {","          result = end;","        }","      }","    }","","    return result;","  }","","  /**","  * Calculates the next invalid date for a particular schedules starting from","  * the specified valid start date.","  *","  * @param {String} dir: The direction to use, either 'next' or 'prev'","  * @param {Array} schedArr: The set of compiled schedules to use","  * @param {Array} startsArr: The set of cached start dates for the schedules","  * @param {Date} startDate: The valid date for which the end date will be found","  * @param {Date} maxEndDate: The latested possible end date or null for none","  */","  function calcEnd(dir, schedArr, startsArr, startDate, maxEndDate) {","    var compare = compareFn(dir), result;","","    for(var i = 0, len = schedArr.length; i &lt; len; i++) {","      var start = startsArr[i];","      if(!start || start.getTime() !== startDate.getTime()) continue;","","      var end = schedArr[i].end(start);","","      // if the end date is past the maxEndDate, just return the maxEndDate","      if(maxEndDate &amp;&amp; compare(end, maxEndDate)) {","        return maxEndDate;","      }","","      // otherwise, return the maximum end date that was calculated","      if(!result || compare(end, result)) {","        result = end;","      }","    }","","    return result;","  }","","  /**","  * Returns a function to use when comparing two dates. Encapsulates the","  * difference between searching for instances forward and backwards so that","  * the same code can be completely reused for both directions.","  *","  * @param {String} dir: The direction to use, either 'next' or 'prev'","  */","  function compareFn(dir) {","    return dir === 'next' ?","      function(a,b) { return a.getTime() &gt; b.getTime(); } :","      function(a,b) { return b.getTime() &gt; a.getTime(); };","  }","","  /**","  * Returns the next value in an array using the function passed in as compare","  * to do the comparison. Skips over null or undefined values.","  *","  * @param {Array} arr: The array of values","  * @param {Function} compare: The comparison function to use","  */","  function findNext(arr, compare) {","    var next = arr[0];","","    for(var i = 1, len = arr.length; i &lt; len; i++) {","      if(arr[i] &amp;&amp; compare(next, arr[i])) {","        next = arr[i];","      }","    }","","    return next;","  }","","","  return {","","    /**","    * Returns true if d is a valid occurrence of the current schedule.","    *","    * @param {Date} d: The date to check","    */","    isValid: function(d) {","      return getInstances('next', 1, d, d) !== undefined;","    },","","    /**","    * Finds the next valid instance or instances of the current schedule,","    * optionally between a specified start and end date. Start date is","    * Date.now() by default, end date is unspecified. Start date must be","    * smaller than end date.","    *","    * @param {Integer} count: The number of instances to return","    * @param {Date} startDate: The earliest a valid instance can occur","    * @param {Date} endDate: The latest a valid instance can occur","    */","    next: function(count, startDate, endDate) {","      return getInstances('next', count || 1, startDate, endDate);","    },","","    /**","    * Finds the previous valid instance or instances of the current schedule,","    * optionally between a specified start and end date. Start date is","    * Date.now() by default, end date is unspecified. Start date must be","    * greater than end date.","    *","    * @param {Integer} count: The number of instances to return","    * @param {Date} startDate: The earliest a valid instance can occur","    * @param {Date} endDate: The latest a valid instance can occur","    */","    prev: function(count, startDate, endDate) {","      return getInstances('prev', count || 1, startDate, endDate);","    },","","    /**","    * Finds the next valid range or ranges of the current schedule,","    * optionally between a specified start and end date. Start date is","    * Date.now() by default, end date is unspecified. Start date must be","    * greater than end date.","    *","    * @param {Integer} count: The number of ranges to return","    * @param {Date} startDate: The earliest a valid range can occur","    * @param {Date} endDate: The latest a valid range can occur","    */","    nextRange: function(count, startDate, endDate) {","      return getInstances('next', count || 1, startDate, endDate, true);","    },","","    /**","    * Finds the previous valid range or ranges of the current schedule,","    * optionally between a specified start and end date. Start date is","    * Date.now() by default, end date is unspecified. Start date must be","    * greater than end date.","    *","    * @param {Integer} count: The number of ranges to return","    * @param {Date} startDate: The earliest a valid range can occur","    * @param {Date} endDate: The latest a valid range can occur","    */","    prevRange: function(count, startDate, endDate) {","      return getInstances('prev', count || 1, startDate, endDate, true);","    }","  };","};"];
_$jscoverage['core/schedule.js'][12]++;
later.schedule = (function (sched) {
  _$jscoverage['core/schedule.js'][13]++;
  if ((! sched)) {
    _$jscoverage['core/schedule.js'][13]++;
    throw new Error("Missing schedule definition.");
  }
  _$jscoverage['core/schedule.js'][14]++;
  if ((! sched.schedules)) {
    _$jscoverage['core/schedule.js'][14]++;
    throw new Error("Definition must include at least one schedule.");
  }
  _$jscoverage['core/schedule.js'][17]++;
  var schedules = [], schedulesLen = sched.schedules.length, exceptions = [], exceptionsLen = (sched.exceptions? sched.exceptions.length: 0);
  _$jscoverage['core/schedule.js'][22]++;
  for (var i = 0; (i < schedulesLen); (i++)) {
    _$jscoverage['core/schedule.js'][23]++;
    schedules.push(later.compile(sched.schedules[i]));
}
  _$jscoverage['core/schedule.js'][26]++;
  for (var j = 0; (j < exceptionsLen); (j++)) {
    _$jscoverage['core/schedule.js'][27]++;
    exceptions.push(later.compile(sched.exceptions[j]));
}
  _$jscoverage['core/schedule.js'][40]++;
  function getInstances(dir, count, startDate, endDate, isRange) {
    _$jscoverage['core/schedule.js'][41]++;
    var compare = compareFn(dir), loopCount = count, schedStarts = [], exceptStarts = [], next, end, results = [];
    _$jscoverage['core/schedule.js'][46]++;
    startDate = (startDate? new Date(startDate): new Date());
    _$jscoverage['core/schedule.js'][47]++;
    if (((! startDate) || (! startDate.getTime()))) {
      _$jscoverage['core/schedule.js'][47]++;
      throw new Error("Invalid start date.");
    }
    _$jscoverage['core/schedule.js'][50]++;
    updateNextStarts(dir, schedules, schedStarts, startDate);
    _$jscoverage['core/schedule.js'][52]++;
    while ((loopCount && (next = findNext(schedStarts, compare)))) {
      _$jscoverage['core/schedule.js'][55]++;
      if (compare(startDate, next)) {
        _$jscoverage['core/schedule.js'][56]++;
        tickStarts(dir, schedules, schedStarts, next);
        _$jscoverage['core/schedule.js'][57]++;
        continue;
      }
      _$jscoverage['core/schedule.js'][61]++;
      if ((endDate && compare(next, endDate))) {
        _$jscoverage['core/schedule.js'][62]++;
        break;
      }
      _$jscoverage['core/schedule.js'][67]++;
      if (exceptionsLen) {
        _$jscoverage['core/schedule.js'][68]++;
        updateRangeStarts(dir, exceptions, exceptStarts, next);
        _$jscoverage['core/schedule.js'][69]++;
        if ((end = calcRangeOverlap(dir, exceptions, exceptStarts, next))) {
          _$jscoverage['core/schedule.js'][70]++;
          updateNextStarts(dir, schedules, schedStarts, end);
          _$jscoverage['core/schedule.js'][71]++;
          continue;
        }
      }
      _$jscoverage['core/schedule.js'][77]++;
      if (isRange) {
        _$jscoverage['core/schedule.js'][78]++;
        end = calcEnd(dir, schedules, schedStarts, next, findNext(exceptStarts, compare));
        _$jscoverage['core/schedule.js'][79]++;
        results.push([new Date(next), new Date(end)]);
        _$jscoverage['core/schedule.js'][83]++;
        end = ((dir === "next")? end: new Date((next.getTime() - 1000)));
        _$jscoverage['core/schedule.js'][84]++;
        updateNextStarts(dir, schedules, schedStarts, end);
      }
      else {
        _$jscoverage['core/schedule.js'][87]++;
        results.push(new Date(next));
        _$jscoverage['core/schedule.js'][88]++;
        tickStarts(dir, schedules, schedStarts, next);
      }
      _$jscoverage['core/schedule.js'][91]++;
      (loopCount--);
}
    _$jscoverage['core/schedule.js'][94]++;
    return ((results.length === 0)? undefined: ((count === 1)? results[0]: results));
}
  _$jscoverage['core/schedule.js'][107]++;
  function updateNextStarts(dir, schedArr, startsArr, startDate) {
    _$jscoverage['core/schedule.js'][108]++;
    var compare = compareFn(dir);
    _$jscoverage['core/schedule.js'][110]++;
    for (var i = 0, len = schedArr.length; (i < len); (i++)) {
      _$jscoverage['core/schedule.js'][111]++;
      if (((! startsArr[i]) || (! compare(startsArr[i], startDate)))) {
        _$jscoverage['core/schedule.js'][112]++;
        startsArr[i] = schedArr[i].start(dir, startDate);
      }
}
}
  _$jscoverage['core/schedule.js'][127]++;
  function updateRangeStarts(dir, schedArr, rangesArr, startDate) {
    _$jscoverage['core/schedule.js'][128]++;
    var compare = compareFn(dir);
    _$jscoverage['core/schedule.js'][130]++;
    for (var i = 0, len = schedArr.length; (i < len); (i++)) {
      _$jscoverage['core/schedule.js'][131]++;
      if (((! rangesArr[i]) || (! compare(rangesArr[i][0], startDate)))) {
        _$jscoverage['core/schedule.js'][132]++;
        var nextStart = schedArr[i].start(dir, startDate);
        _$jscoverage['core/schedule.js'][133]++;
        rangesArr[i] = (nextStart? [nextStart, schedArr[i].end(nextStart)]: undefined);
      }
}
}
  _$jscoverage['core/schedule.js'][147]++;
  function tickStarts(dir, schedArr, startsArr, startDate) {
    _$jscoverage['core/schedule.js'][148]++;
    for (var i = 0, len = schedArr.length; (i < len); (i++)) {
      _$jscoverage['core/schedule.js'][149]++;
      if ((startsArr[i] && (startsArr[i].getTime() === startDate.getTime()))) {
        _$jscoverage['core/schedule.js'][150]++;
        startsArr[i] = schedArr[i].start(dir, schedArr[i].tick(dir, startDate));
      }
}
}
  _$jscoverage['core/schedule.js'][164]++;
  function calcRangeOverlap(dir, schedArr, rangesArr, startDate) {
    _$jscoverage['core/schedule.js'][165]++;
    var compare = compareFn(dir), result;
    _$jscoverage['core/schedule.js'][167]++;
    for (var i = 0, len = schedArr.length; (i < len); (i++)) {
      _$jscoverage['core/schedule.js'][168]++;
      var range = rangesArr[i];
      _$jscoverage['core/schedule.js'][169]++;
      if ((! range)) {
        _$jscoverage['core/schedule.js'][169]++;
        continue;
      }
      _$jscoverage['core/schedule.js'][172]++;
      if (((startDate.getTime() >= range[0].getTime()) && ((! range[1]) || (startDate.getTime() < range[1].getTime())))) {
        _$jscoverage['core/schedule.js'][178]++;
        var end = ((dir === "next")? range[1]: new Date((range[0].getTime() - 1000)));
        _$jscoverage['core/schedule.js'][179]++;
        if (((! result) || compare(end, result))) {
          _$jscoverage['core/schedule.js'][180]++;
          result = end;
        }
      }
}
    _$jscoverage['core/schedule.js'][185]++;
    return result;
}
  _$jscoverage['core/schedule.js'][198]++;
  function calcEnd(dir, schedArr, startsArr, startDate, maxEndDate) {
    _$jscoverage['core/schedule.js'][199]++;
    var compare = compareFn(dir), result;
    _$jscoverage['core/schedule.js'][201]++;
    for (var i = 0, len = schedArr.length; (i < len); (i++)) {
      _$jscoverage['core/schedule.js'][202]++;
      var start = startsArr[i];
      _$jscoverage['core/schedule.js'][203]++;
      if (((! start) || (start.getTime() !== startDate.getTime()))) {
        _$jscoverage['core/schedule.js'][203]++;
        continue;
      }
      _$jscoverage['core/schedule.js'][205]++;
      var end = schedArr[i].end(start);
      _$jscoverage['core/schedule.js'][208]++;
      if ((maxEndDate && compare(end, maxEndDate))) {
        _$jscoverage['core/schedule.js'][209]++;
        return maxEndDate;
      }
      _$jscoverage['core/schedule.js'][213]++;
      if (((! result) || compare(end, result))) {
        _$jscoverage['core/schedule.js'][214]++;
        result = end;
      }
}
    _$jscoverage['core/schedule.js'][218]++;
    return result;
}
  _$jscoverage['core/schedule.js'][228]++;
  function compareFn(dir) {
    _$jscoverage['core/schedule.js'][229]++;
    return ((dir === "next")? (function (a, b) {
  _$jscoverage['core/schedule.js'][230]++;
  return (a.getTime() > b.getTime());
}): (function (a, b) {
  _$jscoverage['core/schedule.js'][231]++;
  return (b.getTime() > a.getTime());
}));
}
  _$jscoverage['core/schedule.js'][241]++;
  function findNext(arr, compare) {
    _$jscoverage['core/schedule.js'][242]++;
    var next = arr[0];
    _$jscoverage['core/schedule.js'][244]++;
    for (var i = 1, len = arr.length; (i < len); (i++)) {
      _$jscoverage['core/schedule.js'][245]++;
      if ((arr[i] && compare(next, arr[i]))) {
        _$jscoverage['core/schedule.js'][246]++;
        next = arr[i];
      }
}
    _$jscoverage['core/schedule.js'][250]++;
    return next;
}
  _$jscoverage['core/schedule.js'][254]++;
  return ({isValid: (function (d) {
  _$jscoverage['core/schedule.js'][262]++;
  return (getInstances("next", 1, d, d) !== undefined);
}), next: (function (count, startDate, endDate) {
  _$jscoverage['core/schedule.js'][276]++;
  return getInstances("next", (count || 1), startDate, endDate);
}), prev: (function (count, startDate, endDate) {
  _$jscoverage['core/schedule.js'][290]++;
  return getInstances("prev", (count || 1), startDate, endDate);
}), nextRange: (function (count, startDate, endDate) {
  _$jscoverage['core/schedule.js'][304]++;
  return getInstances("next", (count || 1), startDate, endDate, true);
}), prevRange: (function (count, startDate, endDate) {
  _$jscoverage['core/schedule.js'][318]++;
  return getInstances("prev", (count || 1), startDate, endDate, true);
})});
});
