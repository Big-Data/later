/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['core/compile.js']) {
  _$jscoverage['core/compile.js'] = [];
  _$jscoverage['core/compile.js'][12] = 0;
  _$jscoverage['core/compile.js'][14] = 0;
  _$jscoverage['core/compile.js'][18] = 0;
  _$jscoverage['core/compile.js'][19] = 0;
  _$jscoverage['core/compile.js'][25] = 0;
  _$jscoverage['core/compile.js'][26] = 0;
  _$jscoverage['core/compile.js'][32] = 0;
  _$jscoverage['core/compile.js'][33] = 0;
  _$jscoverage['core/compile.js'][38] = 0;
  _$jscoverage['core/compile.js'][40] = 0;
  _$jscoverage['core/compile.js'][50] = 0;
  _$jscoverage['core/compile.js'][56] = 0;
  _$jscoverage['core/compile.js'][57] = 0;
  _$jscoverage['core/compile.js'][61] = 0;
  _$jscoverage['core/compile.js'][62] = 0;
  _$jscoverage['core/compile.js'][74] = 0;
  _$jscoverage['core/compile.js'][75] = 0;
  _$jscoverage['core/compile.js'][76] = 0;
  _$jscoverage['core/compile.js'][77] = 0;
  _$jscoverage['core/compile.js'][85] = 0;
  _$jscoverage['core/compile.js'][97] = 0;
  _$jscoverage['core/compile.js'][101] = 0;
  _$jscoverage['core/compile.js'][102] = 0;
  _$jscoverage['core/compile.js'][115] = 0;
  _$jscoverage['core/compile.js'][116] = 0;
  _$jscoverage['core/compile.js'][119] = 0;
  _$jscoverage['core/compile.js'][120] = 0;
  _$jscoverage['core/compile.js'][121] = 0;
  _$jscoverage['core/compile.js'][122] = 0;
  _$jscoverage['core/compile.js'][129] = 0;
  _$jscoverage['core/compile.js'][143] = 0;
}
_$jscoverage['core/compile.js'].source = ["/**","* Compile","* (c) 2013 Bill, BunKat LLC.","*","* Compiles a single schedule definition into a form from which instances can be","* efficiently calculated from.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","later.compile = function(schedDef) {","","  var constraints = [],","      constraintsLen = 0,","      tickConstraint;","","  for(var key in schedDef) {","    var nameParts = key.split('_'),","        name = nameParts[0],","        mod = nameParts[1],","        vals = schedDef[key],","        constraint = mod ? later.modifier[mod](later[name], vals) : later[name];","","    constraints.push({constraint: constraint, vals: vals});","    constraintsLen++;","  }","","  // sort constraints based on their range for best performance (we want to","  // always skip the largest block of time possible to find the next valid","  // value)","  constraints.sort(function(a,b) {","    return a.constraint.range &lt; b.constraint.range;","  });","","  // this is the smallest constraint, we use this one to tick the schedule when","  // finding multiple instances","  tickConstraint = constraints[constraintsLen-1].constraint;","","  return {","","    /**","    * Calculates the start of the next valid occurrence of a particular schedule","    * that occurs on or after the specified start time.","    *","    * @param {String} dir: Direction to search in ('next' or 'prev')","    * @param {Date} startDate: The first possible valid occurrence","    */","    start: function(dir, startDate) {","      var next = startDate,","          nextVal = later.array[dir],","          done;","","/*      console.log('start ---------------------');*/","","      while(!done &amp;&amp; next) {","        done = true;","","        // verify all of the constraints in order since we want to make the","        // largest jumps possible to find the first valid value","        for(var i = 0; i &lt; constraintsLen; i++) {","          var constraint = constraints[i].constraint,","              curVal = constraint.val(next),","              extent = constraint.extent(next),","              newVal = nextVal(curVal, constraints[i].vals, extent);","","/*          console.log('constraint = ' + constraint.name);","          console.log('next = ' + next.toUTCString());","          console.log('curVal = ' + curVal);","          console.log('extent = ' + extent);","          console.log('newVal = ' + newVal);","          console.log('is valid = ' + constraint.isValid(next, newVal));*/","","          if(!constraint.isValid(next, newVal)) {","            next = constraint[dir](next, newVal);","            done = false;","            break; // need to retest all constraints with new date","          }","        }","      }","","/*      console.log('return = ' + next ? tickConstraint.start(next) : undefined);*/","","      // if next, move to start of time period. needed when moving backwards","      return next ? tickConstraint.start(next) : undefined;","    },","","    /**","    * Given a valid start time, finds the next schedule that is invalid.","    * Returns the start time if it is actually invalid. Useful for finding the","    * end of a valid time range.","    *","    * @param {Date} startDate: The first possible valid occurrence","    */","    end: function(startDate) {","","      var result;","","/*      console.log('end ---------------------');*/","","      for(var i = constraintsLen-1; i &gt;= 0; i--) {","        var constraint = constraints[i].constraint,","            curVal = constraint.val(startDate),","            extent = constraint.extent(startDate),","            nextVal = later.array.nextInvalid(curVal, constraints[i].vals, extent),","            next;","","/*        console.log('constraint = ' + constraint.name);","        console.log('start = ' + startDate.toUTCString());","        console.log('curVal = ' + curVal);","        console.log('extent = ' + extent);","        console.log('nextVal = ' + nextVal);","        console.log('is valid = ' + constraint.isValid(startDate, nextVal));*/","","        if(constraint.isValid(startDate, nextVal)) {","          return startDate;","        }","","        if(nextVal !== undefined) { // constraint has invalid value, use that","          next = constraint.next(startDate, nextVal);","          if(!result || result &gt; next) {","            result = next;","          }","        }","      }","","/*      console.log('return = ' + result);*/","","      return result;","    },","","    /**","    * Ticks the date by the minimum constraint in this schedule","    *","    * @param {String} dir: Direction to tick in ('next' or 'prev')","    * @param {Date} date: The start date to tick from","    */","    tick: function(dir, date) {","/*      console.log('TICK');","      console.log('date=' + date);","      console.log('next=' + new Date(tickConstraint.end(date).getTime() + later.SEC));*/","","      return new Date(dir === 'next' ?","        tickConstraint.end(date).getTime() + later.SEC :","        tickConstraint.start(date).getTime() - later.SEC);","    }","","  };","};"];
_$jscoverage['core/compile.js'][12]++;
later.compile = (function (schedDef) {
  _$jscoverage['core/compile.js'][14]++;
  var constraints = [], constraintsLen = 0, tickConstraint;
  _$jscoverage['core/compile.js'][18]++;
  for (var key in schedDef) {
    _$jscoverage['core/compile.js'][19]++;
    var nameParts = key.split("_"), name = nameParts[0], mod = nameParts[1], vals = schedDef[key], constraint = (mod? (later.modifier[mod])(later[name], vals): later[name]);
    _$jscoverage['core/compile.js'][25]++;
    constraints.push({constraint: constraint, vals: vals});
    _$jscoverage['core/compile.js'][26]++;
    (constraintsLen++);
}
  _$jscoverage['core/compile.js'][32]++;
  constraints.sort((function (a, b) {
  _$jscoverage['core/compile.js'][33]++;
  return (a.constraint.range < b.constraint.range);
}));
  _$jscoverage['core/compile.js'][38]++;
  tickConstraint = constraints[(constraintsLen - 1)].constraint;
  _$jscoverage['core/compile.js'][40]++;
  return ({start: (function (dir, startDate) {
  _$jscoverage['core/compile.js'][50]++;
  var next = startDate, nextVal = later.array[dir], done;
  _$jscoverage['core/compile.js'][56]++;
  while (((! done) && next)) {
    _$jscoverage['core/compile.js'][57]++;
    done = true;
    _$jscoverage['core/compile.js'][61]++;
    for (var i = 0; (i < constraintsLen); (i++)) {
      _$jscoverage['core/compile.js'][62]++;
      var constraint = constraints[i].constraint, curVal = constraint.val(next), extent = constraint.extent(next), newVal = nextVal(curVal, constraints[i].vals, extent);
      _$jscoverage['core/compile.js'][74]++;
      if ((! constraint.isValid(next, newVal))) {
        _$jscoverage['core/compile.js'][75]++;
        next = (constraint[dir])(next, newVal);
        _$jscoverage['core/compile.js'][76]++;
        done = false;
        _$jscoverage['core/compile.js'][77]++;
        break;
      }
}
}
  _$jscoverage['core/compile.js'][85]++;
  return (next? tickConstraint.start(next): undefined);
}), end: (function (startDate) {
  _$jscoverage['core/compile.js'][97]++;
  var result;
  _$jscoverage['core/compile.js'][101]++;
  for (var i = (constraintsLen - 1); (i >= 0); (i--)) {
    _$jscoverage['core/compile.js'][102]++;
    var constraint = constraints[i].constraint, curVal = constraint.val(startDate), extent = constraint.extent(startDate), nextVal = later.array.nextInvalid(curVal, constraints[i].vals, extent), next;
    _$jscoverage['core/compile.js'][115]++;
    if (constraint.isValid(startDate, nextVal)) {
      _$jscoverage['core/compile.js'][116]++;
      return startDate;
    }
    _$jscoverage['core/compile.js'][119]++;
    if ((nextVal !== undefined)) {
      _$jscoverage['core/compile.js'][120]++;
      next = constraint.next(startDate, nextVal);
      _$jscoverage['core/compile.js'][121]++;
      if (((! result) || (result > next))) {
        _$jscoverage['core/compile.js'][122]++;
        result = next;
      }
    }
}
  _$jscoverage['core/compile.js'][129]++;
  return result;
}), tick: (function (dir, date) {
  _$jscoverage['core/compile.js'][143]++;
  return new Date(((dir === "next")? (tickConstraint.end(date).getTime() + later.SEC): (tickConstraint.start(date).getTime() - later.SEC)));
})});
});
